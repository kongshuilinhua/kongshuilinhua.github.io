<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>285水果店果篮最小成本问题</title>
    <link href="/2024/12/26/285%E6%B0%B4%E6%9E%9C%E5%BA%97%E6%9E%9C%E7%AF%AE%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/26/285%E6%B0%B4%E6%9E%9C%E5%BA%97%E6%9E%9C%E7%AF%AE%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h3><p>小 C 需要将 <code>n</code> 个编号为 1 到 <code>n</code> 的水果打包成若干个果篮。每个果篮最多可以容纳 <code>m</code> 个水果，且果篮中的水果编号必须连续。每个果篮的成本由以下公式决定：</p><p>[ \text{成本} = k \times \left\lfloor \frac{u + v}{2} \right\rfloor + s ]</p><p>其中：</p><ul><li><code>k</code> 是果篮中水果的数量。</li><li><code>u</code> 是果篮中水果的最大体积。</li><li><code>v</code> 是果篮中水果的最小体积。</li><li><code>s</code> 是一个常数。</li><li>(\left\lfloor x \right\rfloor) 表示对 <code>x</code> 进行下取整。</li></ul><p>目标是找到一种打包方式，使得总成本最小。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题可以使用<strong>动态规划</strong>的方法来解决。设 <code>f[i]</code> 表示前 <code>i</code> 个水果的最小总成本。状态转移方程的核心思想是考虑最后一个果篮包含的水果数量，并选择使总成本最小的分割方式。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol><li><p><strong>初始化：</strong></p><ul><li>定义一个数组 <code>f</code>，长度为 <code>n + 1</code>，初始化所有元素为正无穷大，表示初始状态下成本无限大。</li><li>设置 <code>f[0] = 0</code>，表示不放入任何水果时的成本为 0。</li></ul></li><li><p><strong>动态规划转移：</strong></p><ul><li>遍历每一个水果位置 <code>i</code>（从 1 到 <code>n</code>），尝试将第 <code>i</code> 个水果作为当前果篮的结尾。</li><li>对于每个位置 <code>i</code>，向前遍历最多 <code>m</code> 个水果（因为每个果篮最多容纳 <code>m</code> 个水果），计算当前果篮的成本，并更新 <code>f[i]</code>。</li><li>在遍历过程中，维护当前果篮中水果的最小值 <code>mi</code> 和最大值 <code>mx</code>，以及当前果篮中水果的数量 <code>cnt</code>。</li><li>计算当前果篮的成本，并与之前的最小成本进行比较，取较小值作为 <code>f[i]</code> 的值。</li><li>如果当前果篮中的水果数量达到 <code>m</code>，则停止遍历，避免超过果篮的最大容量。</li></ul></li><li><p><strong>结果输出：</strong></p><ul><li>最终，<code>f[n]</code> 即为将所有 <code>n</code> 个水果打包的最小总成本。</li></ul></li></ol><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">inf = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span>, s: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># f[i] 表示放入i个水果的最小价值</span><br>    f = [inf] * (n + <span class="hljs-number">1</span>)<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    a = [<span class="hljs-number">0</span>] + a  <span class="hljs-comment"># 使水果编号从1开始</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        cnt = <span class="hljs-number">0</span><br>        mi = inf<br>        mx = -inf<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            mi = <span class="hljs-built_in">min</span>(mi, a[j])<br>            mx = <span class="hljs-built_in">max</span>(mx, a[j])<br>            cnt += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 计算当前分组的成本</span><br>            current_cost = f[j - <span class="hljs-number">1</span>] + s + ((mx + mi) // <span class="hljs-number">2</span>) * cnt<br>            <span class="hljs-comment"># 更新f[i]为当前最小成本</span><br>            f[i] = <span class="hljs-built_in">min</span>(f[i], current_cost)<br>            <span class="hljs-keyword">if</span> cnt &gt;= m:<br>                <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 超过最大容量，停止遍历</span><br>    <span class="hljs-keyword">return</span> f[n]<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度：</strong> O(n * m)，其中 <code>n</code> 是水果的数量，<code>m</code> 是果篮的最大容量。对于每个水果位置，需要遍历最多 <code>m</code> 个位置。</li><li><strong>空间复杂度：</strong> O(n)，用于存储动态规划数组 <code>f</code>。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>225小S的黑白块迷宫</title>
    <link href="/2024/12/26/225%E5%B0%8FS%E7%9A%84%E9%BB%91%E7%99%BD%E5%9D%97%E8%BF%B7%E5%AE%AB/"/>
    <url>/2024/12/26/225%E5%B0%8FS%E7%9A%84%E9%BB%91%E7%99%BD%E5%9D%97%E8%BF%B7%E5%AE%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个 n×m 的网格迷宫中，初始位置在左上角 (1,1)，目标是到达右下角 (n,m)。每个格子可以是黑色（表示为 1）或者白色（表示为 0）。移动时可以向上、下、左、右四个方向移动，但不能走出迷宫的边界。要求在移动过程中经过的黑色格子尽可能少。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题可以使用广度优先搜索（BFS）算法来解决。由于需要最小化经过的黑色格子数量，可以将其视为带权图的最短路径问题，其中白色格子的权重为 0，黑色格子的权重为 1。</p><p><strong>BFS 遍历</strong>：</p><ul><li>从队列中取出当前格子 <code>(x, y, d)</code>。</li><li>如果当前的黑色格子数 d 大于已记录的最小值，跳过此格子。</li><li>遍历四个可能的移动方向，计算新位置 <code>(nx, ny)</code>。</li><li>如果新位置在迷宫范围内，并且通过当前路径到达新位置的黑色格子数更少，则更新 dis[nx][ny]并将新位置加入队列。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>dx, dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span>, grid: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    q = deque([(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)])<br>    dis = [[n * m] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    dis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">while</span> q:<br>        x, y, d = q.popleft()<br>        <span class="hljs-keyword">if</span> d &gt; dis[x][y]:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            nx, ny = x + dx[i], y + dy[i]<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; m:<br>                <span class="hljs-keyword">if</span> dis[nx][ny] &gt; dis[x][y] + grid[nx][ny]:<br>                    dis[nx][ny] = dis[x][y] + grid[nx][ny]<br>                    q.append((nx, ny, dis[nx][ny]))<br>    <span class="hljs-keyword">return</span> dis[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]) == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]) == <span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>该算法的时间复杂度为 O(nm)，其中 n 和 m 分别是网格的行数和列数。每个格子最多被访问一次。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度为 O(nm)，用于存储 dis 数组和队列中的元素。</p>]]></content>
    
    
    
    <tags>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>284模板串匹配问题</title>
    <link href="/2024/12/26/284%E6%A8%A1%E6%9D%BF%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/26/284%E6%A8%A1%E6%9D%BF%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题要求在给定的“模板串”中，替换所有的 <code>&#39;?&#39;</code> 以构造出多个不含前导零的正整数，并找出按字典序排列后的第 <code>k</code> 小的数。如果不存在满足条件的第 <code>k</code> 小数，返回 <code>-1</code>。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li><p><strong>前导零检查</strong>：</p><ul><li>首先检查模板串的首字符是否为 <code>&#39;0&#39;</code>，如果是<code>&#39;0&#39;</code>，则直接返回 <code>-1</code>，</li></ul></li><li><p><strong>从后向前替换 <code>&#39;?&#39;</code></strong>：</p><ul><li>假如不考律前导 0 的情况，<code>???</code> 每个<code>?</code>都有十种可选的数字，可以替换为 <code>000</code> 到 <code>999</code>，共 <code>1000</code> 种可能。第 <code>k</code> 小的数，即为第 <code>k - 1</code> 个数。并且每个位置的”<code>?</code>“填入的正应该是<code>k - 1</code>的十进制的每一位数字</li><li>对于从后往前的每一个 <code>&#39;?&#39;</code>，用 <code>k % 10</code> 来替换该位置的字符，并将 <code>k</code> 整除以 <code>10</code>，以便为下一个 <code>&#39;?&#39;</code> 的替换提供新的数字。</li></ul></li><li><p><strong>处理首位 <code>&#39;?&#39;</code></strong>：</p><ul><li>如果首位是 <code>&#39;?&#39;</code>，则需要特别处理：<ul><li>替换为 <code>k + 1</code>，确保首位不是 <code>&#39;0&#39;</code>。</li><li>检查 <code>k + 1</code> 是否小于 <code>10</code>，否则无法替换为单个数字，返回 <code>-1</code>。</li></ul></li></ul></li></ol><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    s = <span class="hljs-built_in">list</span>(s)<br>    <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;0&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span><br>    k -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&quot;?&quot;</span>:<br>            s[i] = <span class="hljs-built_in">str</span>(k % <span class="hljs-number">10</span>)<br>            k //= <span class="hljs-number">10</span><br>    <span class="hljs-comment"># 处理首位是 &#x27;?&#x27; 的情况</span><br>    <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">and</span> k + <span class="hljs-number">1</span> &lt; <span class="hljs-number">10</span>:<br>        s[<span class="hljs-number">0</span>] = <span class="hljs-built_in">str</span>(k + <span class="hljs-number">1</span>)<br>        k = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 如果 k 不等于 0，说明没有找到第 k 小的数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(s) <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;-1&quot;</span><br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是模板串的长度。需要遍历字符串一次进行替换。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，用于存储字符串的列表形式。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>217小R的雪球滚落计算</title>
    <link href="/2024/12/25/217%E5%B0%8FR%E7%9A%84%E9%9B%AA%E7%90%83%E6%BB%9A%E8%90%BD%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/12/25/217%E5%B0%8FR%E7%9A%84%E9%9B%AA%E7%90%83%E6%BB%9A%E8%90%BD%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一座高度为 $H$ 的山上，每个高度 $i$ 处生成了 $a_i$ 个雪球。当雪球从海拔高度 $i$ 滚到地面时，它的体积会膨胀 $x^i$ 倍。也就是说，雪球的初始体积为 $1$，滚动距离 $i$ 会使体积变成 $1 \times x^i$。我们需要计算所有滚落到地面的雪球的总体积，并对结果取模 $10^9 + 7$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p><strong>理解雪球体积膨胀规则</strong>：</p><ul><li>每个雪球从高度 $i$ 滚落到地面时，其体积变为 $x^i$。</li><li>同一高度 $i$ 处有 $a_i$ 个雪球，因此该高度的雪球总体积为 $a_i \times x^i$。</li></ul></li><li><p><strong>计算总体积</strong>：</p><ul><li>对所有高度 $i$，计算 $a_i \times x^i$ 的总和。</li><li>由于体积可能会非常大，需要在计算过程中对每一项取模 $10^9 + 7$，最终结果也取模。</li></ul></li><li><p><strong>优化幂运算</strong>：</p><ul><li>使用 Python 内置的 <code>pow</code> 函数，利用其三个参数形式 <code>pow(x, i + 1, mod)</code>，高效计算 $x^{i+1} \mod (10^9 + 7)$。</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">H: <span class="hljs-built_in">int</span>, x: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">pow</span>(x, i + <span class="hljs-number">1</span>, mod) * a[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a))) % mod<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]) == <span class="hljs-number">2830</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) == <span class="hljs-number">55</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]) == <span class="hljs-number">42</span>)<br></code></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：$O(nlog(n))$，其中 $n$ 是数组 $a$ 的长度。每个雪球体积的计算需要 $O(log(n))$ 的时间复杂度。</li><li><strong>空间复杂度</strong>：$O(1)$，只使用了常数空间存储结果。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>213小R的排列挑战</title>
    <link href="/2024/12/25/213%E5%B0%8FR%E7%9A%84%E6%8E%92%E5%88%97%E6%8C%91%E6%88%98/"/>
    <url>/2024/12/25/213%E5%B0%8FR%E7%9A%84%E6%8E%92%E5%88%97%E6%8C%91%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>小 R 有一个长度为 n 的排列，排列中的数字是 1 到 n 的整数。她每次操作可以选择两个数<code>a_i</code>和<code>a_j</code>进行交换，前提是这两个数的下标 i 和 j 的奇偶性相同（即同为奇数或同为偶数）。目标是通过最少的操作使数组变成升序排列，如果无法实现则输出-1。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p><strong>下标分组</strong>：将数组根据下标的奇偶性分为两部分：</p><ul><li>奇数下标元素（0-based，即索引为 0,2,4,…）</li><li>偶数下标元素（索引为 1,3,5,…）</li></ul></li><li><p><strong>排序验证</strong>：</p><ul><li>奇数下标的元素在最终的升序排列中应该是奇数序列，即<code>1,3,5,...</code>。</li><li>如果奇数下标的排序结果不符合预期，则无法通过交换操作将数组排序，返回-1。</li></ul></li><li><p><strong>逆序数计算</strong>：</p><ul><li>分别计算奇数下标和偶数下标部分的逆序数。</li><li>逆序数代表需要多少次交换才能使该部分有序。</li><li>总交换次数为奇数下标和偶数下标部分的逆序数之和。</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-comment"># from bisect import bisect_right</span><br><span class="hljs-comment"># class BIT:</span><br><span class="hljs-comment">#     def __init__(self, n):</span><br><span class="hljs-comment">#         self.tree = [0] * n  # 注意下标从1开始</span><br><br><span class="hljs-comment">#     def lowbit(self, x):</span><br><span class="hljs-comment">#         return x &amp; (-x)</span><br><br><span class="hljs-comment">#     # arr[i] += val</span><br><span class="hljs-comment">#     def update(self, i, val):</span><br><span class="hljs-comment">#         while i &lt; len(self.tree):</span><br><span class="hljs-comment">#             self.tree[i] += val</span><br><span class="hljs-comment">#             i += self.lowbit(i)</span><br><br><span class="hljs-comment">#     # 返回arr[:i+1]的sum</span><br><span class="hljs-comment">#     def query(self, i):</span><br><span class="hljs-comment">#         res = 0</span><br><span class="hljs-comment">#         while i &gt; 0:</span><br><span class="hljs-comment">#             res += self.tree[i]</span><br><span class="hljs-comment">#             i -= self.lowbit(i)</span><br><span class="hljs-comment">#         return res</span><br><span class="hljs-comment"># 树状数组求解逆序对，时间复杂度为nlogn</span><br><span class="hljs-comment"># def inv(a):</span><br><span class="hljs-comment">#     n = len(a)</span><br><span class="hljs-comment">#     res = 0</span><br><span class="hljs-comment">#     tree = BIT(n + 1)</span><br><span class="hljs-comment">#     b = sorted(a)</span><br><span class="hljs-comment">#     for x in a:</span><br><span class="hljs-comment">#         i = bisect_right(b, x)</span><br><span class="hljs-comment">#         res += tree.query(n) - tree.query(i)</span><br><span class="hljs-comment">#         tree.update(i, 1)</span><br><span class="hljs-comment">#     return res</span><br><br><span class="hljs-comment"># 暴力求解逆序对，时间复杂度为n²</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inv</span>(<span class="hljs-params">a</span>):<br>    n = <span class="hljs-built_in">len</span>(a)<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> a[i] &gt; a[j]:<br>                res += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    odd, even = [], []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            odd.append(a[i])<br>        <span class="hljs-keyword">else</span>:<br>            even.append(a[i])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sorted</span>(odd) != <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)):<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> inv(odd) + inv(even)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) == <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]) == -<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">6</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]) == -<span class="hljs-number">1</span>)<br><br><br></code></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：O(n²)，主要由逆序数的双重循环计算决定。(可以用树状数组求解逆序对，时间复杂度为 O(nlogn))</li><li><strong>空间复杂度</strong>：O(n)，用于存储奇数和偶数下标的元素。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>逆序对 树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>214小R的权值计算</title>
    <link href="/2024/12/25/214%E5%B0%8FR%E7%9A%84%E6%9D%83%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/12/25/214%E5%B0%8FR%E7%9A%84%E6%9D%83%E5%80%BC%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="问题理解"><a href="#问题理解" class="headerlink" title="问题理解"></a>问题理解</h3><p>给定一个长度为 <code>n</code> 的数组 <code>a</code>，小 R 定义任意子数组的权值为 <code>1×b₁ + 2×b₂ + ... + m×bₘ</code>，其中 <code>m</code> 是子数组的长度，<code>b₁, b₂, ..., bₘ</code> 是子数组中的元素。要求计算所有子数组权值的和，结果需对 <code>10^9 + 7</code> 取模。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>b1 b2 b3 b4 b5<br>b1+2b2 b2+2b3 b3+2b4 b4+2b5<br>b1+2b2+3b3 b2+2b3+3b4 b3+2b4+3b5<br>b1+2b2+3b3+4b4 b2+2b3+3b4+4b5<br>b1+2b2+3b3+4b4+5b5<br>根据规律可以看出长度为 length 的子数组转移的时候，只需要加上 length*a[i] - (s[i-1] - s[i-length-1])即可</p></blockquote><ol><li><p><strong>前缀和计算</strong>：<br>使用前缀和 <code>s</code> 来快速计算任意子数组的元素和，<code>s[i]</code> 表示前 <code>i</code> 个元素的和。</p></li><li><p><strong>权值计算</strong>：<br>对于每个子数组长度 <code>length</code>，遍历所有可能的子数组，计算当前子数组的权值 <code>cur</code>。</p><ul><li>初始时，计算第一个长度为 <code>length</code> 的子数组的权值。</li><li>随着窗口的滑动，通过更新 <code>cur</code> 来计算下一个子数组的权值：<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">cur += length * a<span class="hljs-comment">[i]</span> - (s<span class="hljs-comment">[i - 1]</span> - s<span class="hljs-comment">[i - length - 1]</span>)<br></code></pre></td></tr></table></figure>这里，<code>length * a[i]</code> 是新加入元素对权值的贡献，<code>(s[i - 1] - s[i - length - 1])</code> 是窗口内之前元素权值的调整。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> accumulate<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = <span class="hljs-number">0</span><br>    a = [<span class="hljs-number">0</span>] + a<br>    s = <span class="hljs-built_in">list</span>(accumulate(a))<br>    <span class="hljs-comment"># 枚举子数组的长度</span><br>    <span class="hljs-keyword">for</span> length <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        cur = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length + <span class="hljs-number">1</span>):<br>            cur += a[i] * i<br>        res = (res + cur) % mod<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            cur += length * a[i] - (s[i - <span class="hljs-number">1</span>] - s[i - length - <span class="hljs-number">1</span>])<br>            res = (res + cur) % mod<br>    <span class="hljs-keyword">return</span> res % mod<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) == <span class="hljs-number">33</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]) == <span class="hljs-number">203</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>]) == <span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>枚举 前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>211小R的并集大小期望计算</title>
    <link href="/2024/12/24/211%E5%B0%8FR%E7%9A%84%E5%B9%B6%E9%9B%86%E5%A4%A7%E5%B0%8F%E6%9C%9F%E6%9C%9B%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/12/24/211%E5%B0%8FR%E7%9A%84%E5%B9%B6%E9%9B%86%E5%A4%A7%E5%B0%8F%E6%9C%9F%E6%9C%9B%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>小 R 有<code>n</code>个集合，每个集合中的元素都是唯一的且互不相同。她希望通过随机选择两个集合，并计算它们的并集大小，来求出并集大小的期望值。结果需要保留两位小数。题目保证输入至少有两个集合。</p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>要计算随机选择两个集合的并集大小的期望值，关键在于确定每个元素在这两个集合的并集中出现的概率。具体步骤如下：</p><ol><li><p><strong>元素出现次数统计</strong>：</p><ul><li>首先统计每个元素在所有集合中出现的次数。即，元素<code>x</code>出现于<code>v</code>个不同的集合中。</li></ul></li><li><p><strong>计算每个元素在并集中出现的概率</strong>：</p><ul><li>对于一个元素<code>x</code>，它至少出现在所选的两个集合中的一个的概率，可以通过以下公式计算：<script type="math/tex; mode=display">P(x \text{ 出现在并集中}) = 1 - P(x \text{ 不出现在两个集合中})</script></li><li><p><code>x</code>不出现在两个集合中的概率为：</p><script type="math/tex; mode=display">P(x \text{ 不出现在两个集合中}) = \frac{\binom{n - v}{2}}{\binom{n}{2}}</script><p>其中，(\binom{n}{2}) 表示从<code>n</code>个集合中选取两个集合的组合数。</p></li><li><p>因此，<code>x</code>出现在并集中的概率为：</p><script type="math/tex; mode=display">P(x \text{ 出现在并集中}) = 1 - \frac{(n - v) \times (n - v - 1)}{n \times (n - 1)}</script></li></ul></li><li><p><strong>计算期望值</strong>：</p><ul><li>期望值为所有元素在并集中出现概率的总和，即：<script type="math/tex; mode=display">\text{期望值} = \sum_{x} P(x \text{ 出现在并集中})</script></li></ul></li><li><p><strong>结果格式化</strong>：</p><ul><li>最终的期望值需要保留两位小数。</li></ul></li></ol><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, st: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-comment"># 统计所有元素在所有集合中出现的次数</span><br>    cnt = Counter([i <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> st <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s])<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> cnt.items():<br>        <span class="hljs-comment"># 对于每个元素，计算其出现在并集中的概率，并累加到结果中</span><br>        res += n * (n - <span class="hljs-number">1</span>) - (n - v) * (n - v - <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 计算期望值并格式化为两位小数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(res / (n * (n - <span class="hljs-number">1</span>)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]]) == <span class="hljs-string">&#x27;4.00&#x27;</span>)      <span class="hljs-comment"># 输出: True</span><br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]]) == <span class="hljs-string">&#x27;4.67&#x27;</span>)  <span class="hljs-comment"># 输出: True</span><br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">70</span>]]) == <span class="hljs-string">&#x27;5.00&#x27;</span>)  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>209 小R的子数组权值</title>
    <link href="/2024/12/24/209%E5%B0%8FR%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%9D%83%E5%80%BC/"/>
    <url>/2024/12/24/209%E5%B0%8FR%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%9D%83%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小 R 有一个长度为 <code>n</code> 的数组 <code>a</code>，她定义每个子区间 <code>[l, r]</code> 的权值为 <code>a[l] | a[l+1] | ... | a[r]</code>，即该区间内所有元素的按位或运算结果。小 R 非常好奇，在这 <code>n × (n + 1) / 2</code> 个子区间中，究竟有多少种不同的权值。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于两个二进制数 <code>a</code> 和 <code>b</code>，如果满足 <code>a &amp; b = a</code>，从集合的角度来看，<code>a</code> 对应的集合是 <code>b</code> 对应集合的子集。</p><ol><li><p><strong>遍历数组</strong>：仍然从左到右遍历数组 <code>a</code>，对于当前元素 <code>x = a[i]</code>。</p></li><li><p><strong>反向遍历更新</strong>：从索引 <code>i-1</code> 开始，向前遍历 <code>a[j]</code>：</p><ul><li><p><strong>检查子集关系</strong>：</p><ul><li><p>如果 <code>a[j] &amp; x != a[j]</code>，说明 <code>a[j]</code> 可以通过与 <code>x</code> 进行按位与运算而变小（即集合元素减少）。此时，更新 <code>a[j] = a[j] &amp; x</code>，并将更新后的值加入结果集合 <code>res</code> 中。</p></li><li><p>如果 <code>a[j] &amp; x == a[j]</code>，则 <code>x</code> 是 <code>a[j]</code> 的超集。同时，由于之前的遍历已经保证了每个集合都是其左侧相邻集合的超集，<code>x</code> 也必然是所有左侧集合的超集。在这种情况下，进一步的遍历将不会导致任何集合的变化，因此可以直接退出内层循环，提高算法效率。</p></li></ul></li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">a</span>):<br>    res = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):<br>        res.add(x)<br>        j = i - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> a[j] | x != a[j]:<br>            a[j] |= x<br>            res.add(a[j])<br>            j -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(res)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]) == <span class="hljs-number">6</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>]) == <span class="hljs-number">8</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]) == <span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：<code>O(nlog(U))</code>，其中 <code>n</code> 是数组的长度。<code>U</code>是数组中的最大值</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，用于存储不同的权值。</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://leetcode.cn/problems/number-of-subarrays-with-and-value-of-k/">LeetCode - Number of Subarrays With AND Value of K</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>logTrick</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>203小Q和小X的游戏</title>
    <link href="/2024/12/23/203%E5%B0%8FQ%E5%92%8C%E5%B0%8FX%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
    <url>/2024/12/23/203%E5%B0%8FQ%E5%92%8C%E5%B0%8FX%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="203-小-Q-和小-X-的游戏"><a href="#203-小-Q-和小-X-的游戏" class="headerlink" title="203 小 Q 和小 X 的游戏"></a>203 小 Q 和小 X 的游戏</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小 Q 和小 X 是很好的朋友，她们正在玩一个游戏。她们拿到了一个数组，游戏开始时小 Q 随机选择一个元素作为起点。接着，两人轮流行动，小 Q 先行动。</p><p>每次行动时，当前玩家需要选择当前元素左边比它更小的元素，然后移动到该元素，接下来换另一方从这个元素继续移动。如果某一方无法进行合法的移动，则该方输掉游戏。</p><p>小 Q 想知道，在双方都采取最优策略的情况下，她最终获胜的概率是多少？请输出分数的最简形式，即分子和分母互素。如果小 Q 必胜，则输出 <code>1/1</code>。如果小 Q 必败，则输出 <code>0/1</code>。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为起点是随机的，那么一共有 $n$ 种可能的起点。对于每个起点，我们可以通过模拟游戏的过程来判断小 Q 是否能获胜。</p><p>因为双方都采取最优策略，如果当前位置左边没有比它更小的元素，那么当前玩家必败。否则先手的小 Q 可以直接移动到左边的最小元素获得胜利。因此，我们可以通过统计当前位置左边是否存在比它更小的元素来判断小 Q 是否能获胜。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下是基于上述思路的 Python 代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> gcd<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    mi = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> a[i] &gt; mi:<br>            cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            mi = a[i]<br>    <span class="hljs-comment"># 计算最大公约数，化简分数</span><br>    g = gcd(cnt, n)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;cnt//g&#125;</span>/<span class="hljs-subst">&#123;n//g&#125;</span>&#x27;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]) == <span class="hljs-string">&#x27;3/5&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">6</span>, [<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]) == <span class="hljs-string">&#x27;2/3&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>]) == <span class="hljs-string">&#x27;1/4&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>193小K的区间与值和</title>
    <link href="/2024/12/23/193%E5%B0%8FK%E7%9A%84%E5%8C%BA%E9%97%B4%E4%B8%8E%E5%80%BC%E5%92%8C/"/>
    <url>/2024/12/23/193%E5%B0%8FK%E7%9A%84%E5%8C%BA%E9%97%B4%E4%B8%8E%E5%80%BC%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="193-小-K-的区间与值和"><a href="#193-小-K-的区间与值和" class="headerlink" title="193 小 K 的区间与值和"></a>193 小 K 的区间与值和</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小 K 有一个长度为 <code>n</code> 的数组 <code>a</code>，她定义数组的权值为数组中任意两个数按位与（bitwise AND）的值之和。具体来说，对于数组中的每个连续子数组，我们可以计算所有可能的两个元素的按位与值之和，并将这些值相加。小 K 想知道该数组中所有可能的连续子数组的权值和是多少，最后结果对 $10^9 + 7$ 取模。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>为了高效地计算所有连续子数组的权值和，我们需要找到一种方法避免枚举所有可能的子数组和其中的元素对。这可以通过逐位考虑每一位的贡献来实现。</p><p>具体步骤如下：</p><ol><li><p><strong>逐位处理</strong>：对于每一位 <code>i</code>（从第 0 位到第 31 位），计算该位在所有连续子数组中的贡献总和。</p></li><li><p><strong>统计位为 1 的情况</strong>：在数组中，如果某个元素的第 <code>i</code> 位为 1，那么它可以与之前位为 1 的元素形成按位与为 <code>1 &lt;&lt; i</code> 的对。</p></li><li><p><strong>计算子数组数量</strong>：对于 <code>nums[j]</code> 的每一位，考虑每个 <code>pair(i, j)</code> 满足 <code>nums[i] &amp; nums[j] = 1</code>，包含 <code>nums[i:j]</code> 的连续子数组左端点选择范围为 <code>[0 - i]</code>，右端点 <code>[j, n - 1]</code>，一共 <code>(i + 1) * (n - j)</code> 个。对于当前位置 <code>j</code>，我们可以统计出满足条件的 <code>i</code> 的个数累加起来，那么对于当前位置 <code>j</code>，满足条件的子数组个数为 <code>cnt * (n - j)</code>。</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> a[j] &gt;&gt; i &amp; <span class="hljs-number">1</span>:      <span class="hljs-comment"># 当前位是1</span><br>                res += cnt * (n - j) * (<span class="hljs-number">1</span> &lt;&lt; i)<br>                res %= mod<br>                cnt += j + <span class="hljs-number">1</span>  <span class="hljs-comment"># 统计满足条件的i的个数</span><br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) == <span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]) == <span class="hljs-number">25</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>]) == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>]) == <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 算法常用库函数</title>
    <link href="/2024/12/23/1/"/>
    <url>/2024/12/23/1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍一些常用的 py 库函数</p></blockquote><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><ol><li><p><code>abs(x)</code><br>返回一个数字的绝对值。参数可以是整数、浮点数、复数等。如果参数是一个复数，则返回它的模。</p></li><li><p><code>all(iterable)</code><br>如果 iterable 的所有元素均为真值（或可迭代对象为空）则返回 True 。<br>示例代码:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nums</span> =<span class="hljs-meta"> [1, 2, 3, 4, 5]</span><br><span class="hljs-comment"># 检查是否所有元素都是偶数</span><br><span class="hljs-attribute">print</span>(<span class="hljs-literal">all</span>(x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> for x in nums))  # False<br></code></pre></td></tr></table></figure></li><li><p><code>any(iterable)</code></p><p>如果 iterable 的任一元素为真值则返回 True。 如果可迭代对象为空，返回 False。<br>例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nums</span> =<span class="hljs-meta"> [1, 2, 3, 4, 5]</span><br><span class="hljs-comment"># 检查列表中是否包含偶数</span><br><span class="hljs-attribute">print</span>(any(x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> for x in nums))  # True<br></code></pre></td></tr></table></figure></li><li><p><code>bin(x)</code><br>将一个整数转换为带前缀 “0b” 的二进制数字符串。<br>例:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">print</span>(bin(<span class="hljs-number">5</span>)) # <span class="hljs-number">0b101</span><br><span class="hljs-built_in">print</span>(bin(-<span class="hljs-number">6</span>)) # -<span class="hljs-number">0b110</span><br></code></pre></td></tr></table></figure></li><li><p><code>chr(i)</code> 和 <code>ord(c)</code><br>这两个函数互为逆函数。<br><code>chr(i)</code>返回 Unicode 码位为整数<code>i</code> 的字符的字符串格式。<br><code>ord(c)</code>对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span>(<span class="hljs-keyword">chr</span>(<span class="hljs-number">97</span>))  <span class="hljs-comment"># &#x27;a&#x27;</span><br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)) <span class="hljs-comment"># 97</span><br></code></pre></td></tr></table></figure></li><li><p><code>divmod(a, b)</code><br>接受两个数字作为参数并返回由当对其使用整数除法时的商和余数组成的数字对。 结果与 (a // b, a % b) 相同。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>, b = divmod(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>)  # a = <span class="hljs-number">3</span>, b = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p><code>enumerate(iterable, start=0)</code><br>传入一个可迭代对象返回一个元组，里面包含一个计数值（从 start 开始，默认为 0）和通过迭代 iterable 获得的值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nums</span> =<span class="hljs-meta"> [100, 200, 300, 400, 500]</span><br><span class="hljs-comment"># [(1, 100), (2, 200), (3, 300), (4, 400), (5, 500)]</span><br><span class="hljs-attribute">print</span>(list(enumerate(nums, <span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure></li><li><p><code>eval(expression)</code><br>用来执行一个字符串表达式，并返回表达式的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">s = <span class="hljs-string">&quot;1 + 2 * 3 + 8 // 4&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">eval</span>(s))  <span class="hljs-comment"># 9</span><br></code></pre></td></tr></table></figure></li><li><p><code>int(x, base=10)</code><br>将一个字符串或数字转换为整数。如果第二个参数 base 给出，则 x 必须是一个字符串，表示进制数（如 2 表示二进制，8 表示八进制，10 表示十进制，16 表示十六进制）。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;5&#x27;</span>))  <span class="hljs-meta"># 5</span><br><span class="hljs-keyword">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;1010&#x27;</span>, <span class="hljs-number">2</span>))  <span class="hljs-meta"># 10</span><br></code></pre></td></tr></table></figure></li><li><p><code>max(iterable, *[, key, default])</code> 和 <code>min(iterable, *[, key, default])</code><br>大家都知道这两个函数的作用，需要注意的是，如果传入的可迭代对象为空，会抛出 <em>ValueError</em> 异常。可以通过 default 参数设置默认返回值。</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs monkey">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(nums))<span class="hljs-meta">  # 5</span><br>nums2 = []<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(nums2))<span class="hljs-meta">  # ValueError: max() arg is an empty sequence</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(nums2, <span class="hljs-keyword">default</span>=<span class="hljs-number">0</span>))<span class="hljs-meta">  # 0</span><br></code></pre></td></tr></table></figure></li></ol><p>11.<code>pow(base, exp, mod=None)</code><br>返回<em>base</em>的 exp 次幂；如果 mod 存在，则返回结果对 mod 取模。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">print</span>(pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  # <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python 算法 库函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>149小A的移动点</title>
    <link href="/2024/12/23/149%E5%B0%8FA%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%82%B9/"/>
    <url>/2024/12/23/149%E5%B0%8FA%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>小 M 有<code>n</code>个点，每个点的坐标为 ($x_i$, $y_i$)。她可以从一个点出发，沿着坐标轴方向移动，直到到达另一个点。具体来说，可以从 <code>(x1, y1)</code> 直接移动到 <code>(x2, y1)</code> 或者 <code>(x1, y2)</code>，但无法直接移动到 <code>(x2, y2)</code>。为了确保任意两个点之间都可以通过这种路径互相到达，小 M 需要增加最少数量的新点。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个问题可以转化为图论中的连通性问题。将每个点看作图中的一个节点，如果两个点在同一行或同一列，则它们之间有一条边相连。我们需要找到图中的连通分量数目，然后最少需要增加的点数就是连通分量数目减一。</p><p>具体步骤如下：</p><ol><li><strong>并查集（Union-Find）</strong>：使用并查集数据结构来管理点的连接关系，方便快速合并和查找不同连通分量。</li><li><strong>建立行和列的映射</strong>：<ul><li>使用两个字典，<code>row</code> 和 <code>col</code>，分别存储每一行和每一列上的点的索引。</li><li>遍历所有点，将具有相同<code>x</code>坐标的点加入同一行，具有相同<code>y</code>坐标的点加入同一列。</li></ul></li><li><strong>合并连通分量</strong>：<ul><li>对于每一行中的所有点，依次将它们合并到第一点所在的连通分量。</li><li>对于每一列中的所有点，依次将它们合并到第一点所在的连通分量。</li></ul></li><li><strong>计算连通分量</strong>：<ul><li>最终，通过并查集找到所有点的根节点，统计不同的根节点数量，即为连通分量的数目。</li></ul></li><li><strong>得出结果</strong>：<ul><li>最少需要增加的点数为连通分量数目减一。</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, points: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    p = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">if</span> x != p[x]:<br>            p[x] = find(p[x])<br>        <span class="hljs-keyword">return</span> p[x]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>        x, y = find(x), find(y)<br>        <span class="hljs-keyword">if</span> x != y:<br>            p[y] = x<br><br>    row = defaultdict(<span class="hljs-built_in">list</span>)<br>    col = defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> i, (x, y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(points):<br>        row[x].append(i)<br>        col[y].append(i)<br><br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> row.values():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(v)):<br>            union(v[<span class="hljs-number">0</span>], v[i])<br><br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> col.values():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(v)):<br>            union(v[<span class="hljs-number">0</span>], v[i])<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(find(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n))) - <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]]) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>]]) == <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>]]) == <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法 图论 并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>27游戏英雄升级潜力评估 一行代码解决</title>
    <link href="/2024/12/22/27%E6%B8%B8%E6%88%8F%E8%8B%B1%E9%9B%84%E5%8D%87%E7%BA%A7%E6%BD%9C%E5%8A%9B%E8%AF%84%E4%BC%B0-%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/12/22/27%E6%B8%B8%E6%88%8F%E8%8B%B1%E9%9B%84%E5%8D%87%E7%BA%A7%E6%BD%9C%E5%8A%9B%E8%AF%84%E4%BC%B0-%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小 U 在一款挂机游戏中拥有 n 个英雄。游戏中有一种历练升级机制，每天可以选择两个英雄进行历练，如果两位英雄的等级相同，则他们的等级都不会改变。如果英雄等级不同，那么等级较高的英雄会增加 1 级，而等级较低的英雄则保持不变。</p><p>小 U 希望至少有一个英雄能够达到<code>2000000000000000</code>级，现需要确定有多少英雄有潜力通过历练达到这个目标等级。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>要使至少有一个英雄达到<code>2000000000000000</code>级，必须确保有英雄能够不断提升等级。观察历练规则：</p><ul><li><strong>相同等级的英雄</strong>无法提升。</li><li><strong>不同等级的英雄</strong>中，等级较高的英雄每次历练都会增加 1 级。</li></ul><p>因此，只有不是最低等级的英雄才有可能通过不断历练达到高等级。最低等级的英雄无法提升，因此它们不具备达成目标的潜力。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li><strong>找出最低等级</strong>：确定所有英雄中当前的最低等级。</li><li><strong>计算最低等级英雄的数量</strong>：这些英雄无法通过历练提升。</li><li><strong>潜力英雄数量</strong>：总英雄数减去最低等级英雄的数量。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, u: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> n - u.count(<span class="hljs-built_in">min</span>(u))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(n = <span class="hljs-number">5</span>, u = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) == <span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(solution(n = <span class="hljs-number">4</span>, u = [<span class="hljs-number">100000</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">100000</span>]) == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(solution(n = <span class="hljs-number">6</span>, u = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]) == <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19 字典序最小的 01 字符串 简单 O(n)做法</title>
    <link href="/2024/12/22/19-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84-01-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%AE%80%E5%8D%95-O-n-%E5%81%9A%E6%B3%95/"/>
    <url>/2024/12/22/19-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84-01-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%AE%80%E5%8D%95-O-n-%E5%81%9A%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="19-字典序最小的-01-字符串-简单-O-n-做法"><a href="#19-字典序最小的-01-字符串-简单-O-n-做法" class="headerlink" title="19 字典序最小的 01 字符串 简单 O(n)做法"></a>19 字典序最小的 01 字符串 简单 O(n)做法</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 U 拥有一个由<code>0</code>和<code>1</code>组成的字符串，她可以进行最多<code>k</code>次操作。每次操作可以交换相邻的两个字符。目标是通过这些操作，使得最终得到的字符串字典序最小。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>为了获得字典序最小的字符串，我们的目标是尽可能将<code>&#39;0&#39;</code>移向字符串的左侧而把<code>&#39;1&#39;</code>移到字符串的右侧，并且根据字典序的规则，我们应该尽量把<code>&#39;1&#39;</code>和最右边的<code>&#39;0&#39;</code>交换</p><p>具体步骤如下：</p><ol><li><strong>遍历字符串</strong>：从左到右遍历字符串中的每一个字符。</li><li><strong>遇到<code>&#39;0&#39;</code>时尝试和左边的最远的<code>&#39;1&#39;</code>交换</strong>：<ul><li>对于当前位置的<code>&#39;0&#39;</code>，尝试将其向左边移动尽可能多的位置，但移动的步数不能超过剩余的操作次数<code>ops</code>。</li><li>用指针<code>j</code>记录最左边的<code>&#39;1&#39;</code>的位置，并且<code>j</code>具有单调性，因为假设当前的<code>i - j &gt; ops</code>，这意味着本次不能交换，那么当<code>i</code>继续向右移动时,<code>i - j</code>的值只会越来越大，所以<code>j</code>也必须向右继续移动才有可能进行交换。这也意味这<code>j</code>只会从<code>0~n</code>遍历一次，复杂度为$O(n)$</li><li>更新字符串，同时减少相应的操作次数<code>k</code>。</li></ul></li></ol><p>这种方法确保了在每一步操作中，都将当前的<code>&#39;0&#39;</code>尽可能地向左移动，从而整体上达到了字典序最小的目标。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, ops: <span class="hljs-built_in">int</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    s = <span class="hljs-built_in">list</span>(s)<br>    j = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j, i):<br>                <span class="hljs-keyword">if</span> s[k] == <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> (i - k) &lt;= ops:<br>                    s[k] = <span class="hljs-string">&#x27;0&#x27;</span><br>                    s[i] = <span class="hljs-string">&#x27;1&#x27;</span><br>                    ops -= (i - k)<br>                    j = k + <span class="hljs-number">1</span>  <span class="hljs-comment"># 更新j的位置</span><br>                    <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(s)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;01010&quot;</span>) == <span class="hljs-string">&#x27;00101&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;1101001&quot;</span>) == <span class="hljs-string">&#x27;0110101&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;1001&quot;</span>) == <span class="hljs-string">&#x27;0101&#x27;</span>)<br></code></pre></td></tr></table></figure><p>复杂度分析<br>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$<br>用于存储可变的字符串列表。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>146字符串首尾相同子序列计数</title>
    <link href="/2024/12/19/146%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%9B%B8%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0/"/>
    <url>/2024/12/19/146%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%9B%B8%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>小 M 拿到了一个仅由小写字母组成的字符串，她想知道在这个字符串中，有多少个子序列的首尾字符相同。子序列的定义是：从原字符串中按原顺序取出若干字符（可以不连续）组成的新字符串。</p><p>例如，对于字符串 “arcaea”，其子序列包括 “aca”, “ara”, “aaa” 等，这些子序列的首尾字符都是相同的。</p><p>你需要计算满足这一条件的子序列数量，并输出对 998244353 取模的结果。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p><strong>统计字符出现位置</strong>：<br>使用 <code>defaultdict</code> 来存储每个字符在字符串中出现的所有位置。</p></li><li><p><strong>计算子序列数量</strong>：<br>对于每个字符，考虑其所有可能的首尾位置组合 <code>(i, j)</code>，其中 $i &lt; j$。对于每一对 <code>(i, j)</code>，位于 $i$ 和 $j$ 之间的字符可以选择或不选择，因此有 $2^{j - i - 1}$ 种可能的子序列。</p></li><li><p><strong>累加结果</strong>：<br>将所有符合条件的子序列数量累加，同时加上单个字符的情况（每个字符本身也是一个有效的子序列）。</p></li><li><p><strong>取模处理</strong>：<br>最终结果对 <code>998244353</code> 取模。</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    d = defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>        d[c].append(i)<br>    res = <span class="hljs-number">0</span><br>    mod = <span class="hljs-number">998244353</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> d:<br>        v = d[k]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(v)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(v)):<br>                res += <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, v[j] - v[i] - <span class="hljs-number">1</span>, mod)<br>    <span class="hljs-keyword">return</span> (res + <span class="hljs-built_in">len</span>(s)) % mod<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;arcaea&quot;</span>) == <span class="hljs-number">28</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;abcabc&quot;</span>) == <span class="hljs-number">18</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;aaaaa&quot;</span>) == <span class="hljs-number">31</span>)<br></code></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：<code>O(N^2)</code>，其中 <code>N</code> 是字符串的长度。主要消耗在于双重循环遍历每个字符的所有位置组合。</li><li><strong>空间复杂度</strong>：<code>O(N)</code>，用于存储每个字符出现的位置。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>模数应为 <code>998244353</code>，请确保代码中 <code>mod</code> 的值正确。</li><li>由于可能存在大量的子序列，务必在计算中进行取模操作以防止整数溢出。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
