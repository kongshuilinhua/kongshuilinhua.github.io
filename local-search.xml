<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/01/01/test/"/>
    <url>/2025/01/01/test/</url>
    
    <content type="html"><![CDATA[<script type="math/tex; mode=display">A = \begin{bmatrix}        a_{11}    & a_{12}    & ...    & a_{1n}\\        a_{21}    & a_{22}    & ...    & a_{2n}\\        a_{31}    & a_{22}    & ...    & a_{3n}\\        \vdots    & \vdots    & \ddots & \vdots\\        a_{n1}    & a_{n2}    & ... & a_{nn}\\    \end{bmatrix} , b = \begin{bmatrix}        b_{1}  \\        b_{2}  \\        b_{3}  \\        \vdots \\        b_{n}  \\    \end{bmatrix}</script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>309魔幻世界中的安全区计算</title>
    <link href="/2025/01/01/309%E9%AD%94%E5%B9%BB%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E5%8C%BA%E8%AE%A1%E7%AE%97/"/>
    <url>/2025/01/01/309%E9%AD%94%E5%B9%BB%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E5%8C%BA%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>在一个大小为 <code>n x m</code> 的二维数组中，每个格子的值表示该位置的危险程度。小 F 的能力值为 <code>X</code>，当某个格子的危险程度小于等于 <code>X</code> 时，该格子被认为是安全的。相邻（上下左右连通）的安全格子组成一个安全区。需要计算整个二维数组中有多少个安全区。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题本质就是计算连通块的数量。使用广度优先搜索（BFS）遍历二维数组，标记已访问的安全格子。对于每一个未访问且安全的格子，启动一次 BFS，将所有相连的安全格子标记为已访问，并将安全区计数加一。</p><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span>, X: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    vis = [[<span class="hljs-number">0</span>] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">x, y</span>):<br>        q = deque([(x, y)])<br>        vis[x][y] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> q:<br>            x, y = q.popleft()<br>            <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> [(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)]:<br>                nx, ny = x + dx, y + dy<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; m <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> vis[nx][ny] <span class="hljs-keyword">and</span> a[nx][ny] &lt;= X:<br>                    vis[nx][ny] = <span class="hljs-number">1</span><br>                    q.append((nx, ny))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    res = <span class="hljs-built_in">sum</span>(bfs(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m) <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i][j] <span class="hljs-keyword">and</span> a[i][j] &lt;= X)<br>    <span class="hljs-keyword">return</span> res<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]]) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, [[<span class="hljs-number">6</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">4</span>]]) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]) == <span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度</strong>:通过 BFS 方法遍历整个二维数组，每个格子最多只被遍历一次，所以时间复杂度为 <code>O(n * m)</code>。<br><strong>空间复杂度</strong>:空间复杂度 <code>O(n * m)</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>370子区间平均值问题</title>
    <link href="/2025/01/01/370%E5%AD%90%E5%8C%BA%E9%97%B4%E5%B9%B3%E5%9D%87%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <url>/2025/01/01/370%E5%AD%90%E5%8C%BA%E9%97%B4%E5%B9%B3%E5%9D%87%E5%80%BC%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>问题描述</strong></p><p>给定一个长度为 <code>n</code> 的整数数组 <code>arr</code>，以及一个有理数 <code>u/v</code>。需要找出数组中有多少个连续的子区间，其平均值恰好等于 <code>u/v</code>。</p><p><strong>解题思路</strong></p><ol><li><p><strong>转化问题</strong>：要求子区间的平均值等于 <code>u/v</code>，即子区间的总和等于 <code>(u/v) * 长度</code>。为了简化计算，我们可以将数组的每个元素都减去 <code>u/v</code>，然后问题转化为找出有多少个子区间的和为 <code>0</code>。</p></li><li><p><strong>前缀和与哈希表</strong>：</p><ul><li>使用前缀和 <code>s</code> 来记录从起始到当前元素的累积和。</li><li>使用哈希表 <code>d</code> 来存储每个前缀和出现的次数。</li><li>遍历数组，对于每个位置 <code>i</code>，计算当前的前缀和 <code>s[i]</code>：<ul><li>如果在之前的某个位置 <code>j</code>（<code>j &lt; i</code>），<code>s[j]</code> 与 <code>s[i]</code> 相等，则子区间 <code>(j+1, i)</code> 的和为 <code>0</code>。</li><li>因此，结果 <code>res</code> 增加 <code>d[s[i]]</code> 的值。</li><li>然后更新 <code>d[s[i]]</code> 的计数。</li></ul></li></ul></li></ol><p><strong>代码解析</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> accumulate<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, u: <span class="hljs-built_in">int</span>, v: <span class="hljs-built_in">int</span>, arr: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 将每个元素减去 u/v</span><br>    a = [x - u / v <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr]<br>    <span class="hljs-comment"># 计算前缀和</span><br>    s = <span class="hljs-built_in">list</span>(accumulate(a))<br>    <span class="hljs-comment"># 哈希表记录前缀和出现的次数</span><br>    d = defaultdict(<span class="hljs-built_in">int</span>)<br>    d[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-comment"># 如果当前前缀和 s[i] 已存在于哈希表中，则增加相应的计数</span><br>        res += d[s[i]]<br>        <span class="hljs-comment"># 更新哈希表</span><br>        d[s[i]] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度: <code>O(n)</code>，其中 <code>n</code> 为数组的长度。</li><li>空间复杂度: <code>O(n)</code>。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>299红色格子染色方案数计算</title>
    <link href="/2025/01/01/299%E7%BA%A2%E8%89%B2%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2%E6%96%B9%E6%A1%88%E6%95%B0%E8%AE%A1%E7%AE%97/"/>
    <url>/2025/01/01/299%E7%BA%A2%E8%89%B2%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2%E6%96%B9%E6%A1%88%E6%95%B0%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>小 R 有一排长度为 n 的格子，每个格子从左到右编号为 1 到 n。起初，部分格子已经被染成了红色，其他格子则没有颜色。红色格子的状态由一个长度为 n 的字符串 s 描述，其中 s[i] = 1 表示第 i 个格子是红色的，而 s[i] = 0 表示该格子没有颜色。</p><p>小 R 希望通过以下两种操作将所有格子都染成红色：</p><ol><li>如果第 i 个格子是红色的，且 i + 1 ≤ n，则可以将第 i + 1 个没有颜色的格子染成红色。</li><li>如果第 i 个格子是红色的，且 i - 1 ≥ 1，则可以将第 i - 1 个没有颜色的格子染成红色。</li></ol><p>请你帮小 R 计算出，存在多少种不同的染色顺序可以使所有格子最终都被染成红色，并输出答案对 10^9 + 7 取模后的结果。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>1.<strong>子数组内部的染色方案数</strong><br>首先考虑一个长度为<code>k</code>的全部未染色的格子，可以有多少种染色方案。</p><ul><li>假如这段连续的格子处于两个已染色的格子之间，那么这段格子的染色方案数为<code>2^(k-1)</code>。</li><li>假如这段连续的格子只有一端被染色，那么显然只有一种染色方案。</li></ul><ol><li><strong>合并所有的方案数</strong></li></ol><ul><li>假设有<code>x</code>段连续的未染色格子，那么可以发现，这<code>x</code>段格子的染色方案数是独立的，可以相乘。问题相当于把这<code>x</code>段格子放入长度为<code>m</code>的数组中，<code>m</code>为未染色的格子总数。</li><li>例如 有长度为<code>x1</code>、<code>x2</code>、<code>x3</code>、<code>x4</code>的未染色格子，一共有<code>m</code>个未染色格子，放入其中的方案数为<code>C(m, x1) * C(m-x1, x2) * C(m-x1-x2, x3) * C(m-x1-x2-x3, x4)</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>mx = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 预处理组合数</span><br>fac = [<span class="hljs-number">0</span>] * mx<br>fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, mx):<br>    fac[i] = fac[i - <span class="hljs-number">1</span>] * i % mod<br><br>inv_fac = [<span class="hljs-number">0</span>] * mx<br>inv_fac[mx - <span class="hljs-number">1</span>] = <span class="hljs-built_in">pow</span>(fac[mx - <span class="hljs-number">1</span>], -<span class="hljs-number">1</span>, mod)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mx - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>    inv_fac[i - <span class="hljs-number">1</span>] = inv_fac[i] * i % mod<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">comb</span>(<span class="hljs-params">n, m</span>):<br>    <span class="hljs-keyword">if</span> n &lt; m:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> fac[n] * inv_fac[m] % mod * inv_fac[n - m] % mod<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n, s</span>):<br>    a = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;1&#x27;</span>]<br>    <span class="hljs-comment"># 未染色的格子数</span><br>    cnt = n - <span class="hljs-built_in">len</span>(a)<br>    <span class="hljs-comment"># 处理首尾</span><br>    res = comb(cnt, a[<span class="hljs-number">0</span>]) * comb(cnt - a[<span class="hljs-number">0</span>], n - a[-<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) % mod<br>    cnt -= (a[<span class="hljs-number">0</span>] + n - a[-<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(a)):<br>        k = a[i] - a[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 内部的方案数和放置的方案数相乘</span><br>            res *= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, k - <span class="hljs-number">1</span>, mod) * comb(cnt, k) % mod<br>            cnt -= k<br>    <span class="hljs-keyword">return</span> res % mod<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(n = <span class="hljs-number">5</span>,s = <span class="hljs-string">&quot;00101&quot;</span>) == <span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(solution(n = <span class="hljs-number">6</span>,s = <span class="hljs-string">&quot;100001&quot;</span>) == <span class="hljs-number">8</span>)<br>    <span class="hljs-built_in">print</span>(solution(n = <span class="hljs-number">7</span>,s = <span class="hljs-string">&quot;0001000&quot;</span>) == <span class="hljs-number">20</span>)<br><br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(n)</code>，可以预处理<code>pow</code></li><li><strong>空间复杂度</strong>：<code>O(n)</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>326不同子序列计数问题</title>
    <link href="/2024/12/31/326%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/31/326%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>小 U 有一个字符串 <code>s</code>，他想计算该字符串的所有不同非空子序列的个数。子序列是通过删除原字符串中的部分字符（也可以不删除），且保持剩余字符的相对顺序形成的新字符串。</p><p>你的任务是帮助小 U 计算 <code>s</code> 的不同非空子序列的总数，并返回对 $10^9 + 7$ 取余的结果。</p><p><strong>例如</strong>：</p><ul><li>当 <code>s = &quot;abc&quot;</code> 时，所有不同的非空子序列包括 <code>&quot;a&quot;</code>, <code>&quot;b&quot;</code>, <code>&quot;c&quot;</code>, <code>&quot;ab&quot;</code>, <code>&quot;ac&quot;</code>, <code>&quot;bc&quot;</code>, 和 <code>&quot;abc&quot;</code>，总数为 <code>7</code>。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li><p><strong>动态规划状态定义</strong>:</p><ul><li>定义 <code>f[i]</code> 为字符串 <code>s</code> 的前 <code>i</code> 个字符所能形成的不同非空子序列的数量。字典 <code>last</code> 记录每个字符上一次出现的位置。</li></ul></li><li><p><strong>动态规划转移</strong>:</p><ul><li>遍历字符串 <code>s</code>，对于每一个字符 <code>c</code> 在索引 <code>i</code> 位置：<ul><li>如果 <code>c</code> 是第一次出现，即 <code>c</code> 不在 <code>last</code> 中：<ul><li>则 <code>f[i] = f[i-1] * 2 + 1</code>。这里 <code>f[i-1] * 2</code> 表示在所有前 <code>i-1</code> 个子序列基础上，每个子序列可以选择添加或不添加 <code>c</code>，<code>+1</code> 表示包含只有 <code>c</code> 这个字符的子序列。</li></ul></li><li>如果 <code>c</code> 之前出现过：<ul><li>则 <code>f[i] = f[i-1] * 2 - f[last[c] - 1]</code>。<code>f[i-1] * 2</code> 同理，但需要减去 <code>f[last[c] - 1]</code>，以消除由上一次出现 <code>c</code> 到当前 <code>c</code> 之间重复形成的子序列，保证每个子序列唯一。</li></ul></li></ul></li><li>更新 <code>last[c] = i</code>，记录字符 <code>c</code> 的最新出现位置。</li></ul></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    last = &#123;&#125;<br>    n = <span class="hljs-built_in">len</span>(s)<br>    f = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s, <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> last:<br>            f[i] = f[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            f[i] = f[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> - f[last[c] - <span class="hljs-number">1</span>]<br>        last[c] = i<br>        f[i] %= mod<br><br>    <span class="hljs-keyword">return</span> f[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;abc&quot;</span>) == <span class="hljs-number">7</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;aaa&quot;</span>) == <span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;abcd&quot;</span>) == <span class="hljs-number">15</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;abac&quot;</span>) == <span class="hljs-number">13</span>)<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>该算法的时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 是字符串的长度。</li><li>空间复杂度为 <code>O(n)</code>，用于存储动态规划数组 <code>f</code> 和字符最后出现位置的哈希表 <code>last</code>。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>320&#39;icci&#39;型字符串子序列问题</title>
    <link href="/2024/12/31/320-icci-%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/31/320-icci-%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小 U 定义了一种特殊的字符串类型，称为 “icci” 型字符串。要满足这个类型，字符串必须具备以下条件：</p><ol><li>它的长度为 4。</li><li>第一个和第四个字符必须是元音字母（’a’, ‘e’, ‘i’, ‘o’, ‘u’）。</li><li>第二个和第三个字符必须是辅音字母（除了元音以外的字母）。</li><li>该字符串是一个回文串。</li></ol><p>例如，字符串 “awwa” 和 “uttu” 都是 “icci” 型字符串。现在给定一个字符串，小 U 想知道其中有多少个 “icci” 型的子序列。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>记录单个字符的数量、二元组的数量、三元组的数量。因为每次更新只和当前字符有关，可以在<code>O(26)</code>的复杂度下完成每次更新。</p><ol><li><p><strong>更新结果</strong>:</p><ul><li>如果当前字符 <code>c</code> 是元音，将 <code>triplet[x]</code> 加到结果 <code>res</code> 中，表示以 <code>x</code> 结尾的三元组可以形成有效的四元组。</li></ul></li><li><p><strong>更新三元组</strong>:</p><ul><li>如果当前字符 <code>c</code> 不是元音，对每个字母 <code>ch</code>，将 <code>pairCount[ch][x]</code> 加到 <code>triplet[ch]</code> 中，表示以 <code>ch</code> 开头、<code>x</code> 结尾的三元组数量增加。</li></ul></li><li><p><strong>更新二元组</strong>:</p><ul><li>对每个字母 <code>ch</code>，将 <code>cnt[ch]</code> 加到 <code>pairCount[ch][x]</code> 中，表示以 <code>ch</code> 开头、<code>x</code> 结尾的二元组数量增加。</li></ul></li><li><p><strong>更新字母计数</strong>:</p><ul><li>增加当前字母 <code>x</code> 的出现次数 <code>cnt[x]</code>。</li></ul></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>p = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;aeiou&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    cnt = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span>  <span class="hljs-comment"># 每个字符的计数</span><br>    triplet = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span>   <span class="hljs-comment"># 以ch开头的三元组</span><br>    pairCount = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">26</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">26</span>)]  <span class="hljs-comment"># i j 二元组</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>        x = <span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>        <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> p:<br>            res = (res + triplet[x]) % mod<br>        <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> p:<br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">26</span>):<br>                triplet[ch] = (triplet[ch] + pairCount[ch][x]) % mod<br>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">26</span>):<br>            pairCount[ch][x] = (pairCount[ch][x] + cnt[ch]) % mod<br>        cnt[x] += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;iiaabbii&quot;</span>) == <span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;aekekeo&quot;</span>) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;abcdefg&quot;</span>) == <span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p><strong>时间复杂度</strong>：<code>O(26n)</code>，其中 n 是字符串长度。<br><strong>空间复杂度</strong>: <code>O(26 * 26)</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>304计算特定条件下的四元组数量</title>
    <link href="/2024/12/31/304%E8%AE%A1%E7%AE%97%E7%89%B9%E5%AE%9A%E6%9D%A1%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%9B%9B%E5%85%83%E7%BB%84%E6%95%B0%E9%87%8F/"/>
    <url>/2024/12/31/304%E8%AE%A1%E7%AE%97%E7%89%B9%E5%AE%9A%E6%9D%A1%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%9B%9B%E5%85%83%E7%BB%84%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>该题目要求在给定数组中找到满足条件 <code>a[i] + a[j] = a[k] ^ a[l]</code> 且 <code>i &lt; j &lt; k &lt; l</code> 的四元组数量。由于答案可能非常大，需要对 <code>10^9 + 7</code> 取模。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li><p><strong>枚举所有可能的 <code>(i, j)</code> 对</strong>：</p><ul><li>对于每个 数对<code>a[i]</code>和<code>a[j]</code> <code>(i &lt; j)</code>，计算 <code>a[i] + a[j]</code> 的值，并将其存储在字典 <code>d</code> 中，并记录对应<code>a[j]</code>的下标</li><li>对字典 <code>d</code> 中每个键对应的列表进行排序，以便后续使用二分查找。</li></ul></li><li><p><strong>枚举所有可能的 <code>(k, l)</code> 对</strong>：</p><ul><li>对于每个 <code>(k, l)</code>，满足<code>k &lt; l</code>，计算 <code>a[k] ^ a[l]</code> 的值。寻找是否存在 <code>(i, j)</code> 满足 <code>a[i] + a[j] = a[k] ^ a[l]</code> 且 <code>j &lt; k</code>。</li><li>使用 <code>bisect_left</code> 在 <code>d[a[k] ^ a[l]]</code> 中找到满足 <code>j &lt; k</code> 的 <code>j</code> 的数量，并累加到结果 <code>res</code> 中。</li></ul></li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><span class="hljs-keyword">from</span> bisect <span class="hljs-keyword">import</span> bisect_left<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    d = defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>            d[a[i] + a[j]].append(j)<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> d:<br>        d[k].sort()<br>    res = <span class="hljs-built_in">sum</span>(bisect_left(d[a[i] ^ a[j]], i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n))<br>    <span class="hljs-keyword">return</span> res % mod<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>]) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">6</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]) == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">14</span>, [<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">9</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>]) == <span class="hljs-number">33</span>)<br><br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(n^2logn)</code><ul><li>枚举 <code>(i, j)</code> 对需要 <code>O(n^2)</code> 时间。</li><li>对每个 <code>(k, l)</code> 对进行二分查找需要 O(log n) 时间，总体为 <code>O(n^2logn)</code>。</li></ul></li><li><strong>空间复杂度</strong>：<code>O(n^2)</code><ul><li>用于存储所有 <code>(i, j)</code> 对的和。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>枚举</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>322三数之和问题</title>
    <link href="/2024/12/30/322%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/30/322%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>该问题要求在一个整数数组中找到所有满足 <code>i &lt; j &lt; k</code> 且 <code>arr[i] + arr[j] + arr[k] == target</code> 的三元组，并返回这些三元组的数量。由于可能存在大量的组合，结果需要对 $10^9 + 7$ 取模。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li><strong>排序数组</strong>：首先将数组进行排序，方便使用双指针法。</li><li><strong>遍历数组</strong>：固定第一个数 <code>arr[i]</code>，然后使用双指针 <code>j</code> 和 <code>k</code> 来查找剩下的两个数。</li><li><strong>双指针查找</strong>：<ul><li>如果 <code>arr[i] + arr[j] + arr[k]</code> 小于目标值，移动左指针 <code>j</code> 以增大和。</li><li>如果大于目标值，移动右指针 <code>k</code> 以减小和。</li><li>当找到等于目标值的三元组时，需处理可能存在的重复元素：<ul><li>如果 <code>arr[j]</code> 和 <code>arr[k]</code> 相同，则可以从这段区间中任意选择两个数字组合。可以组合出 <code>(k - j + 1) * (k - j) / 2</code> 个三元组。</li><li>否则，计算左右指针处相同元素的个数 <code>l</code> 和 <code>r</code>，并将 <code>l * r</code> 加入结果中。</li></ul></li></ul></li><li><strong>取模</strong>：在每次更新结果时，对结果取模以防止溢出。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">arr: <span class="hljs-built_in">list</span>, t: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    arr.sort()<br>    n = <span class="hljs-built_in">len</span>(arr)<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>):<br>        j, k = i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> j &lt; k:<br>            <span class="hljs-keyword">if</span> arr[i] + arr[j] + arr[k] &lt; t:<br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> arr[i] + arr[j] + arr[k] &gt; t:<br>                k -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> arr[j] == arr[k]:<br>                    res += (k - j + <span class="hljs-number">1</span>) * (k - j) // <span class="hljs-number">2</span><br>                    <span class="hljs-keyword">break</span><br>                l = r = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> arr[j] == arr[j + <span class="hljs-number">1</span>]:<br>                    l += <span class="hljs-number">1</span><br>                    j += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> arr[k] == arr[k - <span class="hljs-number">1</span>]:<br>                    k -= <span class="hljs-number">1</span><br>                    r += <span class="hljs-number">1</span><br>                j += <span class="hljs-number">1</span><br>                k -= <span class="hljs-number">1</span><br>                res = (res + l * r) % mod<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>], <span class="hljs-number">8</span>) == <span class="hljs-number">20</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], <span class="hljs-number">6</span>) == <span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], <span class="hljs-number">9</span>) == <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], <span class="hljs-number">3</span>) == <span class="hljs-number">4</span>)<br><br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：$O(n^2)$，其中 $n$ 是数组的长度。排序需要 $O(n \log n)$，双指针遍历需要 $O(n^2)$。</li><li><strong>空间复杂度</strong>：$O(1)$，只使用了常数级别的额外空间。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>287火车驶入驶出顺序验证问题</title>
    <link href="/2024/12/30/287%E7%81%AB%E8%BD%A6%E9%A9%B6%E5%85%A5%E9%A9%B6%E5%87%BA%E9%A1%BA%E5%BA%8F%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/30/287%E7%81%AB%E8%BD%A6%E9%A9%B6%E5%85%A5%E9%A9%B6%E5%87%BA%E9%A1%BA%E5%BA%8F%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>要验证火车驶出的顺序是否符合栈的先进后出（FILO）规则，我们可以模拟栈的操作过程。具体步骤如下：</p><ol><li><p><strong>初始化</strong>：</p><ul><li>创建一个空栈 <code>st</code>，用于模拟休息区。</li><li>使用指针 <code>j</code> 来跟踪出栈序列 <code>b</code> 的当前元素。</li></ul></li><li><p><strong>模拟入栈和出栈</strong>：</p><ul><li>遍历驶入序列 <code>a</code>，将每个火车编号依次压入栈 <code>st</code>。</li><li>每次压入后，检查栈顶元素是否与出栈序列 <code>b</code> 中当前指针 <code>j</code> 指向的元素相同：<ul><li>如果相同，则弹出栈顶元素，并将指针 <code>j</code> 向后移动一位。</li><li>重复此过程，直到栈为空或栈顶元素不再匹配 <code>b[j]</code>。</li></ul></li></ul></li><li><p><strong>验证结果</strong>：</p><ul><li>遍历完成后，如果所有火车都按照出栈序列 <code>b</code> 顺利弹出，即栈 <code>st</code> 为空，则说明出栈序列合法，返回 <code>True</code>。</li><li>否则，返回 <code>False</code>，表示出栈序列不合法。</li></ul></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span>, b: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    st = []<br>    j = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a:<br>        st.append(x)<br>        <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span> st[-<span class="hljs-number">1</span>] == b[j]:<br>            st.pop()<br>            j += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(st) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) == <span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]) == <span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) == <span class="hljs-literal">False</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) == <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是序列的长度。每个火车编号最多被压入和弹出栈一次。</li><li><strong>空间复杂度</strong>：O(n)，用于模拟栈的空间。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>279最长连续交替01子串问题</title>
    <link href="/2024/12/30/279%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%BA%A4%E6%9B%BF01%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/30/279%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%BA%A4%E6%9B%BF01%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>要解决这个问题，我们需要找到通过将二进制字符串分割并翻转各部分后，能够得到的最长连续交替<code>01</code>子串的长度。关键在于识别字符串中相邻相同字符的位置，然后尝试翻转这些部分以最大化交替子串的长度。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>字符串翻转后并不会影响最长的<code>01</code>串的长度</li><li>题目的操作会使得字符串的头和尾拼接。如果头和尾的字符是相同的，那么最长的<code>01</code>一定在原本的字符串中。</li><li>如果头和尾的字符是不同的，那么最长的<code>01</code>串可能两个部分拼接而成。这两个部分分别是原字符串的前缀和后缀，因此我们只需要找到前缀和后缀中第一个相邻相同字符的位置，然后尝试翻转这两个部分，找到最长的<code>01</code>串即可。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 求最长的01子串</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">s</span>):<br>    mx = cur = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):<br>        <span class="hljs-keyword">if</span> s[i] != s[i-<span class="hljs-number">1</span>]:<br>            cur += <span class="hljs-number">1</span><br>            mx = <span class="hljs-built_in">max</span>(mx, cur)<br>        <span class="hljs-keyword">else</span>:<br>            cur = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> mx<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = get(s)<br>    <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == s[-<span class="hljs-number">1</span>]:<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):<br>        <span class="hljs-keyword">if</span> s[i] == s[i-<span class="hljs-number">1</span>]:<br>            res = <span class="hljs-built_in">max</span>(res, get(s[:i][::-<span class="hljs-number">1</span>] + s[i:][::-<span class="hljs-number">1</span>]))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> s[i] == s[i+<span class="hljs-number">1</span>]:<br>            res = <span class="hljs-built_in">max</span>(res, get(s[:i][::-<span class="hljs-number">1</span>] + s[i:][::-<span class="hljs-number">1</span>]))<br>            <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>272最大化糖果美味值问题</title>
    <link href="/2024/12/30/272%E6%9C%80%E5%A4%A7%E5%8C%96%E7%B3%96%E6%9E%9C%E7%BE%8E%E5%91%B3%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/30/272%E6%9C%80%E5%A4%A7%E5%8C%96%E7%B3%96%E6%9E%9C%E7%BE%8E%E5%91%B3%E5%80%BC%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求在一个长度为 <code>n</code> 的数组中，选择一些糖果作为奖励，满足以下限制规则：</p><ul><li>如果选择了编号为 <code>i</code> 的糖果，那么编号为 <code>i-1</code>、<code>i-2</code>、<code>i+1</code>、<code>i+2</code> 的糖果将不能被选择。</li><li>每个糖果都有一个对应的美味值。</li><li>目标是使所选糖果的美味值之和最大。</li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li><p><strong>动态规划</strong>：</p><p>定义 <code>f[i]</code> 为考虑前 <code>i</code> 个糖果时，满足条件的最大美味值之和。</p></li><li><p><strong>状态转移</strong>：</p><p>对于每个糖果 <code>i</code>，有两种选择：</p><ul><li><strong>不选择</strong>：则 <code>f[i] = max(f[i-1], f[i-2])</code></li><li><strong>选择</strong>：则不能选择 <code>i-1</code>、<code>i-2</code>，因此 <code>f[i] = f[i-3] + a[i]</code></li></ul><p>综合考虑，状态转移方程为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i-1]</span>, f<span class="hljs-selector-attr">[i-2]</span>, f<span class="hljs-selector-attr">[i-3]</span> + <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>空间优化</strong>：</p><p>由于每次只需要记录前三个状态，可以使用三个变量 <code>f1</code>, <code>f2</code>, <code>f3</code> 来代替数组 <code>f</code>，从而降低空间复杂度。</p></li><li><p><strong>返回结果</strong>：</p><p>最终返回 <code>f1</code>，即考虑所有糖果后的最大美味值之和。</p></li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    f1 = f2 = f3 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-comment"># f[i] = max(f[i - 1], f[i - 2], f[i - 3] + a[i])</span><br>        f1, f2, f3 = <span class="hljs-built_in">max</span>(f1, f2, f3 + a[i]), f1, f2<br>    <span class="hljs-keyword">return</span> f1<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">7</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]) == <span class="hljs-number">14</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]) == <span class="hljs-number">18</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">6</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) == <span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是糖果的数量。需要遍历一次数组。</li><li><strong>空间复杂度</strong>：<code>O(1)</code>，仅使用常数级别的额外空间。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>271最大化未出现自然数问题</title>
    <link href="/2024/12/30/271%E6%9C%80%E5%A4%A7%E5%8C%96%E6%9C%AA%E5%87%BA%E7%8E%B0%E8%87%AA%E7%84%B6%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/30/271%E6%9C%80%E5%A4%A7%E5%8C%96%E6%9C%AA%E5%87%BA%E7%8E%B0%E8%87%AA%E7%84%B6%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求在一个长度为 <code>n</code> 的数组中，找出最大的未出现的自然数。具体来说，找到最小的正整数 <code>m</code>，使得 <code>m</code> 没有出现在数组中。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li><p><strong>计数元素频次</strong>：</p><p>使用 <code>Counter</code> 统计数组中每个元素出现的次数。这样可以快速判断某个数字是否存在于数组中。</p></li><li><p><strong>遍历寻找未出现的自然数</strong>：</p><p>从 <code>0</code> 开始，依次检查每个数字 <code>i</code> 是否存在于数组中（即 <code>cnt[i] &gt; 0</code>）。</p><ul><li>如果存在，则继续检查下一个数。由于操作可以把<code>i</code>变成更大的数字，因此可以把多余的<code>i</code>的个数用变量<code>f</code>记录下来。</li><li>如果不存在，那么查看是否还有多余的更小的数字变成当前的数字。如果有则把<code>f</code>的计数减去<code>1</code>,如果没有则返回当前的 <code>i</code> 作为结果。</li></ul></li><li><p><strong>返回结果</strong>：</p><p>如果所有 <code>0</code> 到 <code>n-1</code> 的数字都存在，则返回 <code>n</code>。</p></li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    cnt = Counter(a)<br>    f = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> cnt[i] == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> f &gt; <span class="hljs-number">0</span>:<br>                f -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">else</span>:<br>            f += cnt[i] - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> n<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]) == <span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">6</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) == <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) == <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是数组长度，用于统计元素频次和遍历查找。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，用于存储元素频次。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>262数组子序列的排列个数</title>
    <link href="/2024/12/30/262%E6%95%B0%E7%BB%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%8E%92%E5%88%97%E4%B8%AA%E6%95%B0/"/>
    <url>/2024/12/30/262%E6%95%B0%E7%BB%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%8E%92%E5%88%97%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求计算数组中满足特定条件的子序列数量。具体来说，子序列必须是从 <code>1</code> 到 <code>m</code> 的完整排列，且按升序排列。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li><p><strong>计数元素频次</strong>：</p><p>使用 <code>Counter</code> 统计数组中每个元素出现的次数。这样可以快速获取每个数字出现的数量。</p></li><li><p><strong>迭代构建排列</strong>：</p><p>从 <code>1</code> 开始，依次检查每个数字 <code>i</code> 是否存在于数组中（即 <code>cnt[i] &gt; 0</code>）。</p><ul><li><p>如果存在，当前排列长度为 <code>i</code>，可以选择的方式数为 <code>cnt[i]</code>。</p></li><li><p>将当前选择方式数累乘到一个累积变量 <code>f</code> 中，表示构建长度为 <code>i</code> 的排列的总方式数。</p></li><li><p>将 <code>f</code> 加到最终结果 <code>res</code> 中。</p></li><li>一旦发现某个数字 <code>i</code> 在数组中不存在（即 <code>cnt[i] == 0</code>），说明无法继续构建更长的排列，循环终止。</li></ul></li></ol><h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><p>以样例 1 为例：</p><ul><li>数组 <code>[1, 1, 5, 2, 3, 4]</code> 中元素计数为 <code>&#123;1:2, 5:1, 2:1, 3:1, 4:1&#125;</code>。</li><li><p>依次计算：</p><ul><li><p><code>m=1</code>:</p><p><code>cnt[1] = 2</code> → <code>f = 2</code> → <code>res = 2</code></p></li><li><p><code>m=2</code>:</p><p><code>cnt[2] = 1</code> → <code>f = 2 * 1 = 2</code> → <code>res = 4</code></p></li><li><p><code>m=3</code>:</p><p><code>cnt[3] = 1</code> → <code>f = 2 * 1 * 1 = 2</code> → <code>res = 6</code></p></li><li><p><code>m=4</code>:</p><p><code>cnt[4] = 1</code> → <code>f = 2 * 1 * 1 * 1 = 2</code> → <code>res = 8</code></p></li><li><p><code>m=5</code>:</p><p><code>cnt[5] = 1</code> → <code>f = 2 * 1 * 1 * 1 * 1 = 2</code> → <code>res = 10</code></p></li><li><p><code>m=6</code>:</p><p><code>cnt[6] = 0</code> → 终止</p></li></ul></li><li><p>最终结果为 <code>10</code>。</p></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    cnt = Counter(a)<br>    res = <span class="hljs-number">0</span><br>    f = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> cnt[i] == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span><br>        f *= cnt[i]<br>        res += f<br><br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">6</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) == <span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) == <span class="hljs-number">5</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">7</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]) == <span class="hljs-number">7</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">9</span>, [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>]) == <span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]))<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是数组长度，用于统计元素频次。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，用于存储元素频次。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>260数字匹配问题</title>
    <link href="/2024/12/29/260%E6%95%B0%E5%AD%97%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/29/260%E6%95%B0%E5%AD%97%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h3><p>小 F 拥有一串数字，需按照以下规则将这些数字两两配对：</p><ol><li>数字对中两个数字的差的绝对值必须大于等于给定的差异值 <code>M</code>。</li><li>每个数字只能被配对一次，不能出现在多个数字对中。<br>目标是找出最多能配对出多少对数字。</li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了最大化配对数，采取贪心策略：</p><ol><li><strong>排序</strong>：首先对数字列表 <code>X</code> 进行排序，以便于后续配对时能够高效地找到满足条件的数字对。</li><li><strong>双指针方法</strong>：<ul><li>题目中要求数字两两配对并且不能重复，因此最多的配对个数为$\lfloor \frac{n}{2} \rfloor$，因为数组是有序的。最优的情况一定是其中一个数字来自数组的左半部分，另一个数字来自右半部分</li><li>将列表分为两部分，左指针 <code>l</code> 指向较小的数字，右指针 <code>r</code> 从中间开始指向较大的数字。遍历右指针，尝试找到与左指针指向的数字差值至少为 <code>M</code> 的配对。如果差值小于<code>M</code>，那么继续移动右指针。</li></ul></li><li><strong>终止条件</strong>：当左指针超过中间位置，停止配对过程。</li></ol><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">N: <span class="hljs-built_in">int</span>, M: <span class="hljs-built_in">int</span>, X: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = <span class="hljs-number">0</span><br>    X.sort()  <span class="hljs-comment"># 对列表进行排序</span><br>    l = <span class="hljs-number">0</span>  <span class="hljs-comment"># 初始化左指针</span><br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N // <span class="hljs-number">2</span>, N):  <span class="hljs-comment"># 右指针从中间开始遍历</span><br>        <span class="hljs-keyword">if</span> X[r] - X[l] &gt;= M <span class="hljs-keyword">and</span> l &lt; N // <span class="hljs-number">2</span>:<br>            res += <span class="hljs-number">1</span>  <span class="hljs-comment"># 成功配对，计数器加一</span><br>            l += <span class="hljs-number">1</span>  <span class="hljs-comment"># 移动左指针，确保数字只被使用一次</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>排序的时间复杂度为 <code>O(N log N)</code>。</li><li>空间复杂度<code>O(1)</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>贪心，双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>251巧克力板选择问题</title>
    <link href="/2024/12/29/251%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/29/251%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求在多个背包的承重限制下，计算每个背包中最多可以携带的巧克力板数量。每块巧克力板的重量为其边长的平方。需要为每个背包找到在不超过其最大承重的情况下，能够携带的最多巧克力板数。</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><ol><li><p><strong>动态规划（01 背包）</strong>：</p><ul><li>对于每个背包，使用动态规划来计算在承重限制下可以携带的最大巧克力板数。</li><li>状态 <code>f[j]</code> 表示在承重 <code>j</code> 下可以携带的最大巧克力板数。</li></ul></li><li><p><strong>状态转移</strong>：</p><ul><li>遍历每块巧克力板，重量为 <code>x^2</code>。</li><li>对于每个背包容量 <code>j</code> 从大到小遍历：<ul><li>如果选择当前巧克力板，则 <code>f[j] = max(f[j], f[j - x^2] + 1)</code>。</li></ul></li></ul></li><li><p><strong>优化</strong>：</p><ul><li>计算所有查询中的最大承重 <code>vol</code>，并初始化动态规划数组 <code>f</code>。</li><li>最终对于每个查询，直接返回对应的 <code>f[q]</code>。</li></ul></li></ol><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span>, queries: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:<br>    vol = <span class="hljs-built_in">max</span>(queries)<br>    f = [<span class="hljs-number">0</span>] * (vol + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vol, x ** <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - x ** <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> [f[q] <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> queries]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">15</span>]) == [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>])<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>]) == [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">25</span>]) == [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：$O(nvol)$，其中 <code>n</code> 是巧克力板的数量，<code>vol</code> 是最大承重。</li><li><strong>空间复杂度</strong>：$O(vol)$，使用了一维数组 <code>f</code> 来存储状态。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>01背包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>248小X的区间或值和</title>
    <link href="/2024/12/29/248%E5%B0%8FX%E7%9A%84%E5%8C%BA%E9%97%B4%E6%88%96%E5%80%BC%E5%92%8C/"/>
    <url>/2024/12/29/248%E5%B0%8FX%E7%9A%84%E5%8C%BA%E9%97%B4%E6%88%96%E5%80%BC%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目要求计算数组中所有可能的连续子数组的权值和，权值定义为子数组中所有选取两个元素按位或（OR）的值之和。最终结果需要对 (10^9 + 7) 取模。</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>首先我们不妨考虑一个暴力一些的做法，计算所有数对的按位或值之和。<br>对于数对<code>a[i]</code> 和 <code>a[j]</code>，$(0 &lt;= i &lt; j &lt; n)$。想要连续子数组包含 <code>a[i]</code> 和 <code>a[j]</code>，那么连续子数组的左端点$l$的范围为$0 &lt;= l &lt;= i$，连续子数组的右端点$r$的范围为$j &lt;= r &lt; n$。因此数对的贡献和为<code>(a[i] | a[j]) * (i + 1) * (n - j)</code>所以我们只需要枚举所有数对，将贡献累加即可</p><p>这种方法的时间复杂度为 $O(n ^ 2)$，对于数组长度大于<code>1e5</code>的情况会超时。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">mod</span> = <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>e9 + <span class="hljs-number">7</span>)<br>def solution(n: <span class="hljs-keyword">int</span>, <span class="hljs-keyword">a</span>: <span class="hljs-keyword">list</span>) -&gt; <span class="hljs-keyword">int</span>:<br>    <span class="hljs-keyword">res</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">j</span> in <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">res</span> += (<span class="hljs-keyword">a</span>[i] | <span class="hljs-keyword">a</span>[<span class="hljs-keyword">j</span>]) * (i + <span class="hljs-number">1</span>) * (n - <span class="hljs-keyword">j</span>)<br>            <span class="hljs-keyword">res</span> %= <span class="hljs-keyword">mod</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span> % <span class="hljs-keyword">mod</span><br></code></pre></td></tr></table></figure><p>这种方法的时间复杂度为 $O(n ^ 2)$，对于数组长度大于<code>1e5</code>的情况会超时。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>因为每一个比特位之间相互独立，我们可以分开考虑每一位的贡献。<br>对于数对<code>a[i]</code>和<code>a[j]</code>的第<code>k</code>个比特位,我们同样可以采用上述的暴力思路去枚举每个比特位之间的贡献。</li><li>当前比特位的大小是<code>1 &lt;&lt; k</code>,同时注意到当我们固定<code>a[i]</code>而去枚举<code>a[j]</code>时，连续子数组左端点$l$的范围始终是$0&lt;=l&lt;=i$。那我们直接累加所有右端点的取值不就可以了！！！</li><li>在实现时，我们枚举连续子数组的右端点而累加左端点的值, 根据按位与的性质，当前比特位为<code>1</code>时，左端点可以取任意的值,而当前比特位为<code>0</code>时，只能和左端点包含<code>1</code>的连续子数组产生贡献。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>(a).bit_length()):<br>        cnt0 = cnt1 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> a[j] &gt;&gt; i &amp; <span class="hljs-number">1</span>:<br>                res += (cnt1 + cnt0) * (n - j) * (<span class="hljs-number">1</span> &lt;&lt; i) % mod<br>                cnt1 += j + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                res += cnt1 * (n - j) * (<span class="hljs-number">1</span> &lt;&lt; i) % mod<br>                cnt0 += j + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res % mod<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：$O(nlogm)$，其中 (n) 是数组长度，(m) 是数组中最大值。</li><li>空间复杂度：$O(1)$，使用常数级额外空间。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>246小U走排列问题</title>
    <link href="/2024/12/28/246%E5%B0%8FU%E8%B5%B0%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/28/246%E5%B0%8FU%E8%B5%B0%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在数轴上有 <code>n</code> 个点 <code>a[1], a[2], ..., a[n]</code>，小 U 初始位于原点。她希望按照一定的顺序访问这些点。需要计算在所有不同的访问顺序中，走过的路径的总和。每种顺序对应的路径长度等于她从原点出发依次访问这些点所走的距离之和。最终结果对 (10^9 + 7) 取模。</p><blockquote><p>这题计算贡献的思想和 236 小 U 的数组权值计算问题有一定的相似之处。感兴趣的可以去做一下</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了计算所有排列顺序下路径长度的总和，可以分解路径长度的贡献：</p><ol><li><p><strong>每个点作为起点的贡献</strong>：</p><ul><li>每个点 <code>a[i]</code> 被访问为第一个点时，路径长度增加 <code>|a[i] - 0| = |a[i]|</code>。</li><li>由于有 <code>(n-1)!</code> 种排列方式使得 <code>a[i]</code> 是第一个点，因此总贡献为 <code>a[i] * (n-1)!</code>。</li></ul></li><li><p><strong>每对相邻点之间的贡献</strong>：</p><ul><li>对于每一对不同相邻的点 <code>(a[i], a[j])</code>，<code>|a[i] - a[j]|</code> 会在不同的排列中多次出现。</li><li>排列中一共有<code>n - 1</code>个可以这对相邻点的位置，并且放好这对相邻点之后，剩下的 <code>n - 2</code> 个点的排列方式有 <code>(n-2)!</code> 种。</li><li>因此，这对相邻点之间的贡献为 <code>|a[i] - a[j]| * (n-2)! * (n-1)</code>。我们可以枚举所有的点对，计算它们的贡献。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]<br>    res = <span class="hljs-number">0</span><br>    f = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 计算 (n-2)!</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>): f = f * i % mod<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        res += a[i] * f * (n - <span class="hljs-number">1</span>)    <span class="hljs-comment"># a[i] * (n-1)!</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> i != j:<br>                <span class="hljs-comment"># |a[i] - a[j]| * (n-2)! * (n-1)</span><br>                res += <span class="hljs-built_in">abs</span>(a[i] - a[j]) * f * (n - <span class="hljs-number">1</span>) % mod<br>    <span class="hljs-keyword">return</span> res % mod<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]) == <span class="hljs-number">50</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]) == <span class="hljs-number">324</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>]) == <span class="hljs-number">16</span>)<br><br></code></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。</p><ol><li><strong>优化</strong><ul><li>注意到点<code>a[i]</code> 作为点对中的第一个点的贡献为<code>f * (n - 1) * (a[i] 到其他所有点对的距离和)</code>，因此可以先计算出<code>a[i]</code>到其他所有点的距离和，然后再计算<code>a[i]</code>的贡献。</li><li>如何求<code>a[i]</code>到其他所有点的距离和？可以先对所有点排序，计算前缀和。<br>那么<code>a[i]</code>到其他所有点的距离和为<code>a[i]</code> * 前面的点个数 - 前面的区间和 + 后面的区间和 - a[i] * 后面的点个数。</li></ul></li></ol><p><strong>代码实现如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> accumulate<br>mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getSumAbsoluteDifferences</span>(<span class="hljs-params">nums</span>):<br>    n = <span class="hljs-built_in">len</span>(nums)<br>    s = <span class="hljs-built_in">list</span>(accumulate(nums))<br>    res = [<span class="hljs-number">0</span>] * n          <span class="hljs-comment"># res[i] = 前面的个数 * cur - 前面总和 + 后面的和 - 后面个数 * cur</span><br>    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>        res[i] = (i + <span class="hljs-number">1</span>) * x - s[i] + (s[n - <span class="hljs-number">1</span>] - s[i]) - (n - i - <span class="hljs-number">1</span>) * x<br>        res[i] %= mod<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]<br>    res = <span class="hljs-number">0</span><br>    a.sort()<br>    dis = getSumAbsoluteDifferences(a)<br>    f = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 计算 (n-2)!</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>): f = f * i % mod<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        res = (res + a[i] * f * (n - <span class="hljs-number">1</span>) + dis[i] * (n - <span class="hljs-number">1</span>) * f) % mod<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]) == <span class="hljs-number">50</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]) == <span class="hljs-number">324</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>]) == <span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度为 $O(n \log n)$, 瓶颈在排序上<br>空间复杂度为 $O(n)$。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>244小U的问号替换问题</title>
    <link href="/2024/12/28/244%E5%B0%8FU%E7%9A%84%E9%97%AE%E5%8F%B7%E6%9B%BF%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/28/244%E5%B0%8FU%E7%9A%84%E9%97%AE%E5%8F%B7%E6%9B%BF%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>给定一个由数字字符和 <code>?</code> 组成的字符串，目标是将所有的 <code>?</code> 替换为数字字符，使得替换后的字符串表示的十进制整数是正整数 <code>p</code> 的倍数。由于方案数可能非常大，需要对最终结果取模 (10^9 + 7)。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用动态规划的方法解决此问题。定义 <code>f[i][j]</code> 表示前 <code>i</code> 位替换后的数模 <code>p</code> 等于 <code>j</code> 的方案数。</p><h3 id="动态规划状态"><a href="#动态规划状态" class="headerlink" title="动态规划状态"></a>动态规划状态</h3><ul><li><strong>状态定义</strong>：<code>f[i][j]</code> 表示前 <code>i</code> 位替换后数模 <code>p</code> 等于 <code>j</code> 的方案数。</li><li><strong>初始状态</strong>：<code>f[0][0] = 1</code>，表示前 0 位数模 <code>p</code> 为 0 的方案只有一种，即空串。</li><li><strong>状态转移</strong>：<ul><li>对于每一位字符 <code>c</code>（从第 1 位到第 <code>n</code> 位）：<ul><li>如果 <code>c</code> 是 <code>?</code>，则可以替换为 <code>0</code> 到 <code>9</code> 中的任意一个数字。</li><li>如果 <code>c</code> 是具体数字，则只能替换为该数字。</li></ul></li><li>对于每一个可能的当前模值 <code>j</code>，更新新的模值 <code>(j * 10 + k) % p</code>，其中 <code>k</code> 是替换后的数字。</li></ul></li><li><strong>空间优化</strong>：由于每次只需要用到上一次的状态，可以使用滚动数组进行优化。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># def solution(s: str, p: int) -&gt; int:</span><br><span class="hljs-comment">#     n = len(s)</span><br><span class="hljs-comment">#     f = [[0] * p for _ in range(n + 1)]</span><br><span class="hljs-comment">#     f[0][0] = 1</span><br><span class="hljs-comment">#     for i, c in enumerate(s, 1):</span><br><span class="hljs-comment">#         for j in range(p):</span><br><span class="hljs-comment">#             if c == &quot;?&quot;:</span><br><span class="hljs-comment">#                 for k in range(10):</span><br><span class="hljs-comment">#                     f[i][(j * 10 + k) % p] += f[i - 1][j]</span><br><span class="hljs-comment">#                     f[i][(j * 10 + k) % p] %= mod</span><br><span class="hljs-comment">#             else:</span><br><span class="hljs-comment">#                 f[i][(j * 10 + int(c)) % p] += f[i - 1][j]</span><br><span class="hljs-comment">#                 f[i][(j * 10 + int(c)) % p] %= mod</span><br><span class="hljs-comment">#     return f[n][0]</span><br><br>mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    n = <span class="hljs-built_in">len</span>(s)<br>    pre = [<span class="hljs-number">0</span>] * p<br>    pre[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s, <span class="hljs-number">1</span>):<br>        cur = [<span class="hljs-number">0</span>] * p<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p):<br>            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&quot;?&quot;</span>:<br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>                    cur[(j * <span class="hljs-number">10</span> + k) % p] = (cur[(j * <span class="hljs-number">10</span> + k) % p] + pre[j]) % mod<br>            <span class="hljs-keyword">else</span>:<br>                cur[(j * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(c)) % p] = (cur[(j * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(c)) % p] + pre[j]) % mod<br>        pre = cur.copy()<br>    <span class="hljs-keyword">return</span> cur[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;??&quot;</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">100</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;????1&quot;</span>, <span class="hljs-number">12</span>) == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;1??2&quot;</span>, <span class="hljs-number">3</span>) == <span class="hljs-number">34</span>)<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：$O(n \times p \times 10)$，其中 <code>n</code> 是字符串长度，<code>p</code> 是给定的正整数。</li><li><strong>空间复杂度</strong>：$O(p)$</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>236小U的数组权值计算</title>
    <link href="/2024/12/28/236%E5%B0%8FU%E7%9A%84%E6%95%B0%E7%BB%84%E6%9D%83%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/12/28/236%E5%B0%8FU%E7%9A%84%E6%95%B0%E7%BB%84%E6%9D%83%E5%80%BC%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小 R 定义一个数组的“权值”为相邻两数乘积为奇数的对数。给定一个整数 n，表示数组的长度，即需要求从 1 到 n 的所有排列的权值之和。每个排列包含从 1 到 n 的每个正整数且仅出现一次。由于结果可能非常大，答案需要对 $10^9 + 7$ 取模。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol><li><p><strong>奇数对的选择：</strong></p><ul><li>只有两个奇数的乘积为奇数</li><li>在 1 到 n 的数中，奇数的个数为 $\lceil n/2 \rceil$。</li><li>选择两个不同的奇数有 $\lceil n/2 \rceil \times (\lceil n/2 \rceil - 1)$ 种方法。</li></ul></li><li><p><strong>位置的安排：</strong></p><ul><li>一个奇数对可以出现在排列中的 n-1 个相邻位置中的任意一个位置。</li><li>除去选定的两个奇数后，剩下的 n-2 个元素可以有$(n-2)!$种排列方式。</li></ul></li><li><p><strong>总计：</strong></p><ul><li>将以上部分相乘，得到总权值之和：<br>a(n) = $\lceil n/2 \rceil \times (\lceil n/2 \rceil - 1) \times (n-1)!$</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> ceil<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = ceil(n / <span class="hljs-number">2</span>) * ceil(n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n): res = (res * i) % mod<br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>) == <span class="hljs-number">144</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>) == <span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">6</span>) == <span class="hljs-number">720</span>)<br></code></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>]]></content>
    
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>235小U的好字符串</title>
    <link href="/2024/12/27/235%E5%B0%8FU%E7%9A%84%E5%A5%BD%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/12/27/235%E5%B0%8FU%E7%9A%84%E5%A5%BD%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小 U 定义了一个“好字符串”，它的要求是该字符串中不包含任意长度不小于 2 的回文子串。现在小 U 拿到了一个字符串，她想知道有多少个非空的子序列是“好字符串”。你的任务是帮助她计算出这些子序列的数量。</p><p>例如，对于字符串 <code>&quot;aba&quot;</code>，它的子序列中除了 <code>&quot;aa&quot;</code> 和 <code>&quot;aba&quot;</code> 以外，其余五个子序列都是“好字符串”。</p><p>注意：由于答案可能非常大，你需要对结果取 (10^9 + 7) 进行输出。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目中要求求出一个字符串中不包含任意长度不小于 2 的回文子串的子序列的数量。这里我们可以使用动态规划的方法来解决这个问题。任意一个长度大于等于 3 的回文串，一定包含一个长度为 2 的回文串或者长度为 3 的字符串。所以我们可以记录子序列中选择的前两个字符，然后遍历字符串，如果当前字符和前两个字符都不相等，那么我们可以选择当前字符，否则我们只能选择不选择当前字符。最后我们将所有的选择情况相加即可。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 记忆化搜索</span><br><span class="hljs-comment"># from functools import cache</span><br><span class="hljs-comment"># def solution(s: str) -&gt; int:</span><br><span class="hljs-comment">#     mod = int(1e9 + 7)</span><br><span class="hljs-comment">#     def dfs(i, pre1, pre2):</span><br><span class="hljs-comment">#         if i == len(s):</span><br><span class="hljs-comment">#             return 1</span><br><span class="hljs-comment">#         res = 0</span><br>          <span class="hljs-comment"># 不选择当前字符</span><br><span class="hljs-comment">#         res += dfs(i + 1, pre1, pre2)</span><br><span class="hljs-comment">#         if s[i] != pre1 and s[i] != pre2:</span><br><span class="hljs-comment">#             res += dfs(i + 1, pre2, s[i])</span><br><span class="hljs-comment">#         return res</span><br>      <span class="hljs-comment"># 不包含空序列</span><br><span class="hljs-comment">#     res = dfs(0, -1, -1) - 1</span><br><span class="hljs-comment">#     return res</span><br><br><span class="hljs-comment"># 动态规划</span><br>mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    n = <span class="hljs-built_in">len</span>(s)<br>    m = <span class="hljs-number">26</span><br>    f = [[<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s:<br>        c = <span class="hljs-built_in">ord</span>(ch) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">27</span>):<br>            <span class="hljs-keyword">if</span> i == c:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">27</span>):<br>                <span class="hljs-keyword">if</span> j == c:<br>                    <span class="hljs-keyword">continue</span><br>                f[j][c] += f[i][j]<br>                f[j][c] %= mod<br>        f[-<span class="hljs-number">1</span>][c] += <span class="hljs-number">1</span><br>    res = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">sum</span>(f[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">27</span>))<br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;aba&quot;</span>) == <span class="hljs-number">5</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;aaa&quot;</span>) == <span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;ghij&quot;</span>) == <span class="hljs-number">15</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;zyyzbyn&quot;</span>) == <span class="hljs-number">51</span>)<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：$O(nm^2)$</li><li><strong>空间复杂度</strong>：$O(m^2)$</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>229小U的chi权值计算</title>
    <link href="/2024/12/27/229%E5%B0%8FU%E7%9A%84chi%E6%9D%83%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/12/27/229%E5%B0%8FU%E7%9A%84chi%E6%9D%83%E5%80%BC%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个由字符<code>&#39;c&#39;</code>、<code>&#39;h&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;?&#39;</code>组成的字符串，其中<code>&#39;?&#39;</code>可以替换为<code>&#39;c&#39;</code>、<code>&#39;h&#39;</code>或<code>&#39;i&#39;</code>。定义字符串的权值基于所有字符<code>&#39;h&#39;</code>的位置计算。对于每个<code>&#39;h&#39;</code>，其前面的<code>&#39;c&#39;</code>和后面的<code>&#39;i&#39;</code>都会对其贡献 1 的权值。求所有可能替换方案的权值之和，结果对 (10^9 + 7) 取模。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><strong>统计未知字符</strong>：首先统计字符串中 <code>?</code> 的总数，用 <code>cnt</code> 表示。</li><li><strong>前缀计数</strong>：<ul><li><code>prec</code> 记录当前位置前面的 <code>c</code> 数量。</li><li><code>pre</code> 记录前面 <code>?</code> 的数量。</li></ul></li><li><strong>后缀计数</strong>：<ul><li><code>sufi</code> 记录当前位置后面的 <code>i</code> 数量。</li><li><code>suf</code> 记录后面 <code>?</code> 的数量。</li></ul></li><li><strong>遍历字符串</strong>：<ul><li>对于每个字符：<ul><li>如果是 <code>c</code>，则增加 <code>prec</code>。</li><li>如果是 <code>i</code>，则减少 <code>sufi</code>。</li><li>如果是 <code>h</code>，计算其贡献：<ul><li>固定 <code>h</code> 的贡献为 <code>prec + sufi</code>，乘以当前 <code>?</code> 的排列组合数。每个 <code>?</code> 都可以替换成 <code>c</code>、<code>h</code>、<code>i</code> 这三种字符，所以总共的替换方案为 <code>pow(3, cnt, mod)</code>。因此前面的 <code>c</code> 和 <code>i</code> 的贡献为 <code>pow(3, cnt, mod) * (prec + sufi)</code>。</li><li>考虑前面的 <code>?</code> 替换为 <code>c</code> 和后面的 <code>?</code> 替换为 <code>i</code> 的情况。前面的 <code>?</code> 替换成 <code>c</code> 也有贡献，一个 <code>?</code> 在 <code>pow(3, cnt - 1, mod)</code> 种情况下可以替换成 <code>c</code>，而当前位置前面共有<code>pre</code>个<code>?</code>,所以前面的 <code>?</code> 的贡献为 <code>pre * pow(3, cnt - 1, mod)</code>。后面的 <code>?</code> 同理为 <code>suf * pow(3, cnt - 1, mod)</code>。</li></ul></li><li>如果是 <code>?</code>，考虑其替换为 <code>h</code> 的情况，类似地计算贡献，并更新 <code>pre</code> 和 <code>suf</code>。当前的 <code>?</code> 已经替换成了 <code>h</code>，所以后面的 <code>?</code> 的贡献为 <code>suf * pow(3, cnt - 2, mod)</code>。前面的 <code>?</code> 同理为 <code>pre * pow(3, cnt - 2, mod)</code>。</li></ul></li></ul></li><li><strong>取模</strong>：最终结果对 (10^9 + 7) 取模。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    pre = <span class="hljs-number">0</span><br>    cnt = suf = s.count(<span class="hljs-string">&#x27;?&#x27;</span>)<br>    prec = <span class="hljs-number">0</span><br>    sufi = s.count(<span class="hljs-string">&#x27;i&#x27;</span>)<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;i&#x27;</span>:<br>            sufi -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">&#x27;c&#x27;</span>:<br>            prec += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">&quot;h&quot;</span>:<br>            res = (res + <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, cnt, mod) * (prec + sufi) + pre * <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, cnt - <span class="hljs-number">1</span>, mod) + suf * <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, cnt - <span class="hljs-number">1</span>, mod)) % mod<br>        <span class="hljs-keyword">else</span>:<br>            suf -= <span class="hljs-number">1</span><br>            res = (res + <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, cnt - <span class="hljs-number">1</span>, mod) * (prec + sufi) + pre * <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, cnt - <span class="hljs-number">2</span>, mod) + suf * <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, cnt - <span class="hljs-number">2</span>, mod)) % mod<br>            pre += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;ch?hi&quot;</span>) == <span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;ccch&quot;</span>) == <span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;c?i&quot;</span>) == <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：(O(n))，其中(n)是字符串的长度。（实现中可以预处理快速幂的结果，使每步计算都是(O(1))的时间复杂度）</li><li><strong>空间复杂度</strong>：(O(1))，只使用了常数额外空间。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>组合 贡献</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>206小R的二叉树探险</title>
    <link href="/2024/12/27/206%E5%B0%8FR%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E9%99%A9/"/>
    <url>/2024/12/27/206%E5%B0%8FR%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E9%99%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个神奇的二叉树中，结构非常独特：每层的节点值赋值方向是交替的，第一层从左到右，第二层从右到左，以此类推，且该二叉树有无穷多层。<br>小 R 对这个二叉树充满了好奇，她想知道，在二叉树中两个节点之间 x, y 的路径长度是多少。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>不妨直接考虑一颗二叉树全部从左到右编号的情况，这样我们可以获取 x 和 y 在这颗树中的编号，它们之间的相对距离不变</p><ul><li>奇数层（1、3、5、…）从左到右编号。因此位于奇数层的节点的编号不变</li><li>偶数层（2、4、6、…）从右到左编号。因此，对于偶数层，需要进行编号的对称转换。<br>第<code>k</code>层一共有<code>2^(k-1)</code>个节点，编号从<code>2^(k-1)</code>到<code>2^k-1</code>，并且观察左右对称的节点的编号总和不变，为<code>2^(k-1) + 2^k - 1</code>。因此，对于偶数层的节点<code>n</code>，其对称编号为<code>2^(k-1) + 2^k - 1 - n</code>。</li></ul><p>找到节点 <code>x</code> 和 <code>y</code> 到根节点的路径，并记录每个节点在路径中的深度，遍历两个路径，找到最近的公共祖先节点，计算路径长度。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">def</span> get_path(n):<br>    <span class="hljs-attribute">d1</span> = &#123;&#125;<br>    <span class="hljs-attribute">k</span> = n.bit_length()<br>    <span class="hljs-attribute">if</span> k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-attribute">n</span> = <span class="hljs-number">2</span> ** k + <span class="hljs-number">2</span> ** (k - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span> - n<br>    <span class="hljs-attribute">for</span> i in range(k):<br>        <span class="hljs-attribute">d1</span>[n] = i<br>        <span class="hljs-attribute">n</span> //= <span class="hljs-number">2</span><br>    <span class="hljs-attribute">return</span> d1<br><span class="hljs-attribute">def</span> solution(x: int, y: int) -&gt; int:<br>    <span class="hljs-attribute">d1</span> = get_path(x)<br>    <span class="hljs-attribute">d2</span> = get_path(y)<br>    <span class="hljs-attribute">res</span> = min(d1[k] + d2[k] for k in d1.keys() &amp; d2.keys())<br>    <span class="hljs-attribute">return</span> res<br><br><span class="hljs-attribute">if</span> __name__ == &#x27;__main__&#x27;:<br>    <span class="hljs-attribute">print</span>(solution(<span class="hljs-number">11</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">5</span>)<br>    <span class="hljs-attribute">print</span>(solution(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">3</span>)<br>    <span class="hljs-attribute">print</span>(solution(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git命令</title>
    <link href="/2024/12/26/Git%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/12/26/Git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-基本命令"><a href="#Linux-基本命令" class="headerlink" title="Linux 基本命令"></a>Linux 基本命令</h1><h2 id="1-目录操作"><a href="#1-目录操作" class="headerlink" title="1.目录操作"></a>1.目录操作</h2><h3 id="1-1-切换目录"><a href="#1-1-切换目录" class="headerlink" title="1.1 切换目录"></a>1.1 切换目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /xxx/xxx          #切换到指定目录<br>cd ~                 #切换到当前用户的家目录<br>cd -                 #切换到上次访问的目录<br>cd .                 #当前目录<br>cd ..                #切换到上级目录<br>cd /                 #切换到根目录<br></code></pre></td></tr></table></figure><h3 id="1-2-查看目录"><a href="#1-2-查看目录" class="headerlink" title="1.2 查看目录"></a>1.2 查看目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls                   #查看当前目录下的文件<br>ls -l                #查看当前目录下的文件详细信息(等价于ll)<br>ls -a                #查看当前目录下的所有文件(包括隐藏文件)<br>ls -lh               #查看当前目录下的文件详细信息(包括文件大小)<br></code></pre></td></tr></table></figure><h3 id="1-3-创建目录"><a href="#1-3-创建目录" class="headerlink" title="1.3 创建目录"></a>1.3 创建目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir xxx            #创建一个目录<br>mkdir /xxx/xxx       #创建一个目录<br></code></pre></td></tr></table></figure><h3 id="1-4-删除目录"><a href="#1-4-删除目录" class="headerlink" title="1.4 删除目录"></a>1.4 删除目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm /path/to/file          # 删除指定文件<br>rm -r /path/to/directory   # 递归删除目录及其内容<br>rm -rf /path/to/directory  # 递归强制删除目录及其内容<br></code></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-r(recursion)</code>：递归删除，用于删除目录及其内部所有文件和子目录。</li><li><code>-f(force)</code>：强制删除，忽略不存在的文件并且不显示任何提示。</li></ul><h3 id="1-5-移动和重命名"><a href="#1-5-移动和重命名" class="headerlink" title="1.5 移动和重命名"></a>1.5 移动和重命名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv 当前目录名 新目录名        # 修改目录名，同样适用于文件操作<br>mv /usr/tmp/tool /opt          # 将 /usr/tmp 目录下的 tool 目录剪切到 /opt 目录下面<br><br></code></pre></td></tr></table></figure><h2 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2.文件操作"></a>2.文件操作</h2><h3 id="2-1-创建文件"><a href="#2-1-创建文件" class="headerlink" title="2.1 创建文件"></a>2.1 创建文件</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">touch</span> <span class="hljs-number">1</span>.txt   # 在当前目录下创建<span class="hljs-number">1</span>.txt<br></code></pre></td></tr></table></figure><h3 id="2-2-删除文件"><a href="#2-2-删除文件" class="headerlink" title="2.2 删除文件"></a>2.2 删除文件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">rm</span> 文件名              <span class="hljs-comment"># 删除当前目录下的文件</span><br><span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> 文件名           <span class="hljs-comment"># 删除当前目录的的文件（不询问）</span><br></code></pre></td></tr></table></figure><h3 id="2-3-编辑文件"><a href="#2-3-编辑文件" class="headerlink" title="2.3 编辑文件"></a>2.3 编辑文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>进入后，操作界面有三种模式：命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">### 命令模式</span></span><br>- 刚进入文件就是命令模式，通过方向键控制光标位置<br>- 使用命令 `dd` 删除当前整行<br>- 使用命令 `/字段` 进行查找<br>- 按 `i` 在光标所在字符前开始插入<br>- 按 `a` 在光标所在字符后开始插入<br>- 按 `o` 在光标所在行的下面另起一新行插入<br>- 按 `:` 进入底行模式<br>- 使用 `yy` 复制当前行<br>- 使用 `p(小写)` 在光标后粘贴<br>- 使用 `P(大写)` 在光标前粘贴<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">### 插入模式</span></span><br>- 此时可以对文件内容进行编辑，左下角会显示 &quot;-- 插入 --&quot;<br>- 按 `ESC` 进入底行模式<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">### 底行模式</span></span><br>- 退出编辑：`:q`<br>- 强制退出：`:q!`<br>- 保存并退出：`:wq`<br><br></code></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li><p><strong>启动 vi 编辑器：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi filename.txt<br></code></pre></td></tr></table></figure><p>打开文件后，默认进入命令模式。</p></li><li><p><strong>从插入模式切换到命令模式：</strong></p><ul><li>按 <code>i</code> 进入插入模式。</li><li>完成编辑后，按 <code>ESC</code> 返回命令模式。</li></ul></li><li><p><strong>从底行模式切换到命令模式：</strong></p><ul><li>在命令模式下，按 <code>:</code> 进入底行模式。</li><li>输入命令（例如 <code>:wq</code>）后，按 <code>Enter</code> 返回命令模式。</li></ul></li></ul><h3 id="2-4-查看文件"><a href="#2-4-查看文件" class="headerlink" title="2.4 查看文件"></a>2.4 查看文件</h3><h4 id="2-4-1-cat-命令"><a href="#2-4-1-cat-命令" class="headerlink" title="2.4.1. cat 命令"></a>2.4.1. <code>cat</code> 命令</h4><p><code>cat</code>（concatenate）命令用于一次性显示整个文件内容，或者将多个文件连接起来输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat filename.txt          # 显示文件内容<br>cat file1.txt file2.txt   # 连接并显示多个文件的内容<br></code></pre></td></tr></table></figure><h4 id="2-4-2-less命令"><a href="#2-4-2-less命令" class="headerlink" title="2.4.2 less命令"></a>2.4.2 <code>less</code>命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">less filename.txt    # 分页查看文件内容<br></code></pre></td></tr></table></figure><h1 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h1><h2 id="1-获取本地仓库"><a href="#1-获取本地仓库" class="headerlink" title="1.获取本地仓库"></a>1.获取本地仓库</h2><p>进入目标目录后右键点击 <code>Git Bash Here</code> 运行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git init<br></code></pre></td></tr></table></figure><p>成功之后可在文件夹下看到<code>.git</code>文件夹</p><h2 id="2-基础操作指令"><a href="#2-基础操作指令" class="headerlink" title="2.基础操作指令"></a>2.基础操作指令</h2><h3 id="2-1-Git-的三个主要区域"><a href="#2-1-Git-的三个主要区域" class="headerlink" title="2.1 Git 的三个主要区域"></a>2.1 Git 的三个主要区域</h3><p>在 Git 中，文件的修改会在不同的区域之间转换，这些区域主要包括工作区（Working Directory）、暂存区（Staging Area）和版本库（Repository）。理解这些区域的关系对于有效地使用 Git 至关重要。</p><ol><li><strong>工作区（Working Directory）</strong><ul><li><strong>描述</strong>：工作区是你在文件系统中实际看到和操作的项目目录。在这里，你可以编辑、添加、删除文件。</li><li><strong>状态</strong>：当你在工作区中对文件进行修改时，这些文件处于“已修改”（modified）状态。</li></ul></li><li><strong>暂存区（Staging Area）</strong><ul><li><strong>描述</strong>：暂存区是一个临时区域，用于存放即将提交到版本库的文件变更。</li><li><strong>状态</strong>：通过 <code>git add</code> 命令，你可以将工作区中已修改的文件添加到暂存区，这些文件此时处于“已暂存”（staged）状态。</li></ul></li><li><strong>版本库（Repository）</strong><ul><li><strong>描述</strong>：版本库是 Git 用来存储项目历史记录的地方。当你提交（commit）变更时，这些变更会被记录在版本库中。</li><li><strong>状态</strong>：通过 <code>git commit</code> 命令，暂存区中的文件变更会被提交到版本库，文件状态变为“已提交”（committed）。</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git status   # 查看当前工作区和暂存区的状态<br>git add .    # 将当前目录下的所有变更添加到暂存区<br>git commit -m &quot;提交信息&quot; # 将暂存区的变更提交到版本库，并添加提交信息<br></code></pre></td></tr></table></figure><h3 id="2-2-查看提交日志"><a href="#2-2-查看提交日志" class="headerlink" title="2.2 查看提交日志"></a>2.2 查看提交日志</h3><p><strong>作用</strong>：查看提交记录</p><p><strong>命令形式</strong>：<code>git log [option]</code></p><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>--all</code>：显示所有分支</li><li><code>--pretty=oneline</code>：将提交信息显示为一行</li><li><code>--abbrev-commit</code>：使得输出的 commit ID 更简短</li><li><code>--graph</code>：以图的形式显示</li></ul><p>每次输入这些参数非常的麻烦，我们可以使用别名简化<br>打开<code>gitbash</code>，执行<code>touch ~/.bashrc</code>，然后在文件中添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">用于输出git提交日志</span><br>alias git-log=&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;<br><span class="hljs-meta prompt_"> #</span><span class="language-bash">用于输出当前目录所有文件及基本信息</span><br>alias ll=&#x27;ls -al&#x27;<br></code></pre></td></tr></table></figure><p>关闭文件后让执行文件生效，执行<code>source ~/.bashrc</code>，然后执行<code>git-log</code>即可查看提交日志</p><h3 id="2-3-版本回退"><a href="#2-3-版本回退" class="headerlink" title="2.3 版本回退"></a>2.3 版本回退</h3><p>可以通过日志产看提交的版本号，然后使用<code>git reset</code>命令回退到指定版本<br>使用<code>git reflog</code>命令可以查看已经删除的提交记录</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">commitID</span>    <span class="hljs-comment"># 回退到指定版本</span><br></code></pre></td></tr></table></figure><h3 id="2-4-添加忽略文件"><a href="#2-4-添加忽略文件" class="headerlink" title="2.4 添加忽略文件"></a>2.4 添加忽略文件</h3><p>可以在项目根目录下创建<code>.gitignore</code>文件，然后在文件中添加需要忽略的文件或目录，这样提交时就不会提交这些文件<br>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有.txt结尾的文件</span><br>*.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略1.doc文件</span><br>1.doc<br><br></code></pre></td></tr></table></figure><h2 id="3-分支操作"><a href="#3-分支操作" class="headerlink" title="3.分支操作"></a>3.分支操作</h2><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：<br>早建分支！多用分支！<br>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p><p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的 parent 提交进行新的工作。”</p><h3 id="3-1-创建分支"><a href="#3-1-创建分支" class="headerlink" title="3.1 创建分支"></a>3.1 创建分支</h3><p>使用 <code>git branch &lt;分支名&gt;</code> 来创建一个新分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch main<br></code></pre></td></tr></table></figure><h3 id="3-2-切换分支"><a href="#3-2-切换分支" class="headerlink" title="3.2 切换分支"></a>3.2 切换分支</h3><p>使用 <code>git checkout &lt;分支名&gt;</code> 来切换到指定分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br></code></pre></td></tr></table></figure><p>使用 <code>git checkout -b &lt;分支名&gt;</code> 可以同时创建并切换到新分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b master<br></code></pre></td></tr></table></figure><h3 id="3-3-合并分支"><a href="#3-3-合并分支" class="headerlink" title="3.3 合并分支"></a>3.3 合并分支</h3><p>使用 <code>git merge &lt;分支名&gt;</code> 将指定分支合并到当前分支。<br>需要先切换到要合并到的分支，然后再执行合并操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 假设当前在 main 分支上, 将 master 分支合并到 main 分支</span><br>git merge master<br></code></pre></td></tr></table></figure><h3 id="3-4-删除分支"><a href="#3-4-删除分支" class="headerlink" title="3.4 删除分支"></a>3.4 删除分支</h3><p>使用 <code>git branch -d &lt;分支名&gt;</code> 删除本地分支。<br>注意： 不能删除当前所在的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d b1 <span class="hljs-comment"># 删除分支时，需要做各种检查</span><br>git branch -D b1 <span class="hljs-comment"># 强制删除</span><br></code></pre></td></tr></table></figure><h2 id="4-操作远程仓库"><a href="#4-操作远程仓库" class="headerlink" title="4 操作远程仓库"></a>4 操作远程仓库</h2><h3 id="4-1-创建远程仓库"><a href="#4-1-创建远程仓库" class="headerlink" title="4.1 创建远程仓库"></a>4.1 创建远程仓库</h3><p>在<code>github</code>或<code>gitee</code>上创建一个新的仓库，在本地库中执行以下命令生成 SSH 公钥(文件路径为<code>C:\Users\用户名\.ssh\id_rsa.pub</code>)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>打开文件或者用命令<code>cat ~/.ssh/id_rsa.pub</code>查看公钥内容并将文件内容复制到远程仓库的 SSH 密钥中。</p><h3 id="4-2-添加远程仓库"><a href="#4-2-添加远程仓库" class="headerlink" title="4.2 添加远程仓库"></a>4.2 添加远程仓库</h3><p>此操作是先初始化本地库，然后与已创建的远程库进行对接。</p><p>命令： <code>git remote add &lt;远端名称&gt; &lt;仓库路径&gt;</code></p><p>远端名称，默认是 origin，取决于远端服务器设置。仓库路径，从远端服务器获取此 URL</p><p>例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:kongshuilinhua/kongshuilinhua.github.io.git<br></code></pre></td></tr></table></figure><h4 id="4-3-查看远程仓库"><a href="#4-3-查看远程仓库" class="headerlink" title="4.3 查看远程仓库"></a>4.3 查看远程仓库</h4><p>命令：<code>git remote</code></p><h4 id="4-4-推送到远程仓库"><a href="#4-4-推送到远程仓库" class="headerlink" title="4.4 推送到远程仓库"></a>4.4 推送到远程仓库</h4><p><code>git push [options] [远程仓库] [本地分支]:[远程分支]</code><br>如果远程分支名和本地分支名称相同，则可以只写本地分支。<br><code>git push</code> 命令的可选参数包括：</p><ul><li><code>-u</code> 或 <code>--set-upstream</code>：设置上游分支</li><li><code>--force</code> 或 <code>-f</code>：强制推送，即使会覆盖远程分支。</li><li><code>--all</code>：推送所有本地分支。</li><li><code>--tags</code>：推送所有本地标签。</li><li><code>--dry-run</code>：模拟推送，不执行实际操作。</li><li><code>--delete</code>：删除远程分支。</li><li><code>--mirror</code>：推送所有引用（包括标签和远程分支）。</li><li><code>--atomic</code>：确保所有分支一起推送成功，否则全部失败。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master<br>git push --set-upstream origin master<br></code></pre></td></tr></table></figure><ul><li><code>-f</code>表示强制覆盖</li><li><code>--set-upstream</code>表示推送到远端的同时并且建立起和远端分支的关联关系。<br>如果当前分支已经和远端分支关联，则可以省略分支名和远端名。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push  <span class="hljs-comment"># 将master分支推送到已关联的远端分支</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>285水果店果篮最小成本问题</title>
    <link href="/2024/12/26/285%E6%B0%B4%E6%9E%9C%E5%BA%97%E6%9E%9C%E7%AF%AE%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/26/285%E6%B0%B4%E6%9E%9C%E5%BA%97%E6%9E%9C%E7%AF%AE%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h3><p>小 C 需要将 <code>n</code> 个编号为 1 到 <code>n</code> 的水果打包成若干个果篮。每个果篮最多可以容纳 <code>m</code> 个水果，且果篮中的水果编号必须连续。每个果篮的成本由以下公式决定：</p><p>[ \text{成本} = k \times \left\lfloor \frac{u + v}{2} \right\rfloor + s ]</p><p>其中：</p><ul><li><code>k</code> 是果篮中水果的数量。</li><li><code>u</code> 是果篮中水果的最大体积。</li><li><code>v</code> 是果篮中水果的最小体积。</li><li><code>s</code> 是一个常数。</li><li>(\left\lfloor x \right\rfloor) 表示对 <code>x</code> 进行下取整。</li></ul><p>目标是找到一种打包方式，使得总成本最小。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题可以使用<strong>动态规划</strong>的方法来解决。设 <code>f[i]</code> 表示前 <code>i</code> 个水果的最小总成本。状态转移方程的核心思想是考虑最后一个果篮包含的水果数量，并选择使总成本最小的分割方式。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol><li><p><strong>初始化：</strong></p><ul><li>定义一个数组 <code>f</code>，长度为 <code>n + 1</code>，初始化所有元素为正无穷大，表示初始状态下成本无限大。</li><li>设置 <code>f[0] = 0</code>，表示不放入任何水果时的成本为 0。</li></ul></li><li><p><strong>动态规划转移：</strong></p><ul><li>遍历每一个水果位置 <code>i</code>（从 1 到 <code>n</code>），尝试将第 <code>i</code> 个水果作为当前果篮的结尾。</li><li>对于每个位置 <code>i</code>，向前遍历最多 <code>m</code> 个水果（因为每个果篮最多容纳 <code>m</code> 个水果），计算当前果篮的成本，并更新 <code>f[i]</code>。</li><li>在遍历过程中，维护当前果篮中水果的最小值 <code>mi</code> 和最大值 <code>mx</code>，以及当前果篮中水果的数量 <code>cnt</code>。</li><li>计算当前果篮的成本，并与之前的最小成本进行比较，取较小值作为 <code>f[i]</code> 的值。</li><li>如果当前果篮中的水果数量达到 <code>m</code>，则停止遍历，避免超过果篮的最大容量。</li></ul></li><li><p><strong>结果输出：</strong></p><ul><li>最终，<code>f[n]</code> 即为将所有 <code>n</code> 个水果打包的最小总成本。</li></ul></li></ol><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">inf = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span>, s: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># f[i] 表示放入i个水果的最小价值</span><br>    f = [inf] * (n + <span class="hljs-number">1</span>)<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    a = [<span class="hljs-number">0</span>] + a  <span class="hljs-comment"># 使水果编号从1开始</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        cnt = <span class="hljs-number">0</span><br>        mi = inf<br>        mx = -inf<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            mi = <span class="hljs-built_in">min</span>(mi, a[j])<br>            mx = <span class="hljs-built_in">max</span>(mx, a[j])<br>            cnt += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 计算当前分组的成本</span><br>            current_cost = f[j - <span class="hljs-number">1</span>] + s + ((mx + mi) // <span class="hljs-number">2</span>) * cnt<br>            <span class="hljs-comment"># 更新f[i]为当前最小成本</span><br>            f[i] = <span class="hljs-built_in">min</span>(f[i], current_cost)<br>            <span class="hljs-keyword">if</span> cnt &gt;= m:<br>                <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 超过最大容量，停止遍历</span><br>    <span class="hljs-keyword">return</span> f[n]<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度：</strong> O(n * m)，其中 <code>n</code> 是水果的数量，<code>m</code> 是果篮的最大容量。对于每个水果位置，需要遍历最多 <code>m</code> 个位置。</li><li><strong>空间复杂度：</strong> O(n)，用于存储动态规划数组 <code>f</code>。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>225小S的黑白块迷宫</title>
    <link href="/2024/12/26/225%E5%B0%8FS%E7%9A%84%E9%BB%91%E7%99%BD%E5%9D%97%E8%BF%B7%E5%AE%AB/"/>
    <url>/2024/12/26/225%E5%B0%8FS%E7%9A%84%E9%BB%91%E7%99%BD%E5%9D%97%E8%BF%B7%E5%AE%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个 n×m 的网格迷宫中，初始位置在左上角 (1,1)，目标是到达右下角 (n,m)。每个格子可以是黑色（表示为 1）或者白色（表示为 0）。移动时可以向上、下、左、右四个方向移动，但不能走出迷宫的边界。要求在移动过程中经过的黑色格子尽可能少。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题可以使用广度优先搜索（BFS）算法来解决。由于需要最小化经过的黑色格子数量，可以将其视为带权图的最短路径问题，其中白色格子的权重为 0，黑色格子的权重为 1。</p><p><strong>BFS 遍历</strong>：</p><ul><li>从队列中取出当前格子 <code>(x, y, d)</code>。</li><li>如果当前的黑色格子数 d 大于已记录的最小值，跳过此格子。</li><li>遍历四个可能的移动方向，计算新位置 <code>(nx, ny)</code>。</li><li>如果新位置在迷宫范围内，并且通过当前路径到达新位置的黑色格子数更少，则更新 dis[nx][ny]并将新位置加入队列。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>dx, dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span>, grid: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    q = deque([(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)])<br>    dis = [[n * m] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    dis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">while</span> q:<br>        x, y, d = q.popleft()<br>        <span class="hljs-keyword">if</span> d &gt; dis[x][y]:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            nx, ny = x + dx[i], y + dy[i]<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; m:<br>                <span class="hljs-keyword">if</span> dis[nx][ny] &gt; dis[x][y] + grid[nx][ny]:<br>                    dis[nx][ny] = dis[x][y] + grid[nx][ny]<br>                    q.append((nx, ny, dis[nx][ny]))<br>    <span class="hljs-keyword">return</span> dis[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]) == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]) == <span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>该算法的时间复杂度为 O(nm)，其中 n 和 m 分别是网格的行数和列数。每个格子最多被访问一次。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度为 O(nm)，用于存储 dis 数组和队列中的元素。</p>]]></content>
    
    
    
    <tags>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>284模板串匹配问题</title>
    <link href="/2024/12/26/284%E6%A8%A1%E6%9D%BF%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/26/284%E6%A8%A1%E6%9D%BF%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题要求在给定的“模板串”中，替换所有的 <code>&#39;?&#39;</code> 以构造出多个不含前导零的正整数，并找出按字典序排列后的第 <code>k</code> 小的数。如果不存在满足条件的第 <code>k</code> 小数，返回 <code>-1</code>。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li><p><strong>前导零检查</strong>：</p><ul><li>首先检查模板串的首字符是否为 <code>&#39;0&#39;</code>，如果是<code>&#39;0&#39;</code>，则直接返回 <code>-1</code>，</li></ul></li><li><p><strong>从后向前替换 <code>&#39;?&#39;</code></strong>：</p><ul><li>假如不考律前导 0 的情况，<code>???</code> 每个<code>?</code>都有十种可选的数字，可以替换为 <code>000</code> 到 <code>999</code>，共 <code>1000</code> 种可能。第 <code>k</code> 小的数，即为第 <code>k - 1</code> 个数。并且每个位置的”<code>?</code>“填入的正应该是<code>k - 1</code>的十进制的每一位数字</li><li>对于从后往前的每一个 <code>&#39;?&#39;</code>，用 <code>k % 10</code> 来替换该位置的字符，并将 <code>k</code> 整除以 <code>10</code>，以便为下一个 <code>&#39;?&#39;</code> 的替换提供新的数字。</li></ul></li><li><p><strong>处理首位 <code>&#39;?&#39;</code></strong>：</p><ul><li>如果首位是 <code>&#39;?&#39;</code>，则需要特别处理：<ul><li>替换为 <code>k + 1</code>，确保首位不是 <code>&#39;0&#39;</code>。</li><li>检查 <code>k + 1</code> 是否小于 <code>10</code>，否则无法替换为单个数字，返回 <code>-1</code>。</li></ul></li></ul></li></ol><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    s = <span class="hljs-built_in">list</span>(s)<br>    <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;0&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span><br>    k -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&quot;?&quot;</span>:<br>            s[i] = <span class="hljs-built_in">str</span>(k % <span class="hljs-number">10</span>)<br>            k //= <span class="hljs-number">10</span><br>    <span class="hljs-comment"># 处理首位是 &#x27;?&#x27; 的情况</span><br>    <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">and</span> k + <span class="hljs-number">1</span> &lt; <span class="hljs-number">10</span>:<br>        s[<span class="hljs-number">0</span>] = <span class="hljs-built_in">str</span>(k + <span class="hljs-number">1</span>)<br>        k = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 如果 k 不等于 0，说明没有找到第 k 小的数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(s) <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;-1&quot;</span><br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是模板串的长度。需要遍历字符串一次进行替换。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，用于存储字符串的列表形式。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>217小R的雪球滚落计算</title>
    <link href="/2024/12/25/217%E5%B0%8FR%E7%9A%84%E9%9B%AA%E7%90%83%E6%BB%9A%E8%90%BD%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/12/25/217%E5%B0%8FR%E7%9A%84%E9%9B%AA%E7%90%83%E6%BB%9A%E8%90%BD%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一座高度为 $H$ 的山上，每个高度 $i$ 处生成了 $a_i$ 个雪球。当雪球从海拔高度 $i$ 滚到地面时，它的体积会膨胀 $x^i$ 倍。也就是说，雪球的初始体积为 $1$，滚动距离 $i$ 会使体积变成 $1 \times x^i$。我们需要计算所有滚落到地面的雪球的总体积，并对结果取模 $10^9 + 7$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p><strong>理解雪球体积膨胀规则</strong>：</p><ul><li>每个雪球从高度 $i$ 滚落到地面时，其体积变为 $x^i$。</li><li>同一高度 $i$ 处有 $a_i$ 个雪球，因此该高度的雪球总体积为 $a_i \times x^i$。</li></ul></li><li><p><strong>计算总体积</strong>：</p><ul><li>对所有高度 $i$，计算 $a_i \times x^i$ 的总和。</li><li>由于体积可能会非常大，需要在计算过程中对每一项取模 $10^9 + 7$，最终结果也取模。</li></ul></li><li><p><strong>优化幂运算</strong>：</p><ul><li>使用 Python 内置的 <code>pow</code> 函数，利用其三个参数形式 <code>pow(x, i + 1, mod)</code>，高效计算 $x^{i+1} \mod (10^9 + 7)$。</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">H: <span class="hljs-built_in">int</span>, x: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">pow</span>(x, i + <span class="hljs-number">1</span>, mod) * a[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a))) % mod<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]) == <span class="hljs-number">2830</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) == <span class="hljs-number">55</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]) == <span class="hljs-number">42</span>)<br></code></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：$O(nlog(n))$，其中 $n$ 是数组 $a$ 的长度。每个雪球体积的计算需要 $O(log(n))$ 的时间复杂度。</li><li><strong>空间复杂度</strong>：$O(1)$，只使用了常数空间存储结果。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>213小R的排列挑战</title>
    <link href="/2024/12/25/213%E5%B0%8FR%E7%9A%84%E6%8E%92%E5%88%97%E6%8C%91%E6%88%98/"/>
    <url>/2024/12/25/213%E5%B0%8FR%E7%9A%84%E6%8E%92%E5%88%97%E6%8C%91%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>小 R 有一个长度为 n 的排列，排列中的数字是 1 到 n 的整数。她每次操作可以选择两个数<code>a_i</code>和<code>a_j</code>进行交换，前提是这两个数的下标 i 和 j 的奇偶性相同（即同为奇数或同为偶数）。目标是通过最少的操作使数组变成升序排列，如果无法实现则输出-1。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p><strong>下标分组</strong>：将数组根据下标的奇偶性分为两部分：</p><ul><li>奇数下标元素（0-based，即索引为 0,2,4,…）</li><li>偶数下标元素（索引为 1,3,5,…）</li></ul></li><li><p><strong>排序验证</strong>：</p><ul><li>奇数下标的元素在最终的升序排列中应该是奇数序列，即<code>1,3,5,...</code>。</li><li>如果奇数下标的排序结果不符合预期，则无法通过交换操作将数组排序，返回-1。</li></ul></li><li><p><strong>逆序数计算</strong>：</p><ul><li>分别计算奇数下标和偶数下标部分的逆序数。</li><li>逆序数代表需要多少次交换才能使该部分有序。</li><li>总交换次数为奇数下标和偶数下标部分的逆序数之和。</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-comment"># from bisect import bisect_right</span><br><span class="hljs-comment"># class BIT:</span><br><span class="hljs-comment">#     def __init__(self, n):</span><br><span class="hljs-comment">#         self.tree = [0] * n  # 注意下标从1开始</span><br><br><span class="hljs-comment">#     def lowbit(self, x):</span><br><span class="hljs-comment">#         return x &amp; (-x)</span><br><br><span class="hljs-comment">#     # arr[i] += val</span><br><span class="hljs-comment">#     def update(self, i, val):</span><br><span class="hljs-comment">#         while i &lt; len(self.tree):</span><br><span class="hljs-comment">#             self.tree[i] += val</span><br><span class="hljs-comment">#             i += self.lowbit(i)</span><br><br><span class="hljs-comment">#     # 返回arr[:i+1]的sum</span><br><span class="hljs-comment">#     def query(self, i):</span><br><span class="hljs-comment">#         res = 0</span><br><span class="hljs-comment">#         while i &gt; 0:</span><br><span class="hljs-comment">#             res += self.tree[i]</span><br><span class="hljs-comment">#             i -= self.lowbit(i)</span><br><span class="hljs-comment">#         return res</span><br><span class="hljs-comment"># 树状数组求解逆序对，时间复杂度为nlogn</span><br><span class="hljs-comment"># def inv(a):</span><br><span class="hljs-comment">#     n = len(a)</span><br><span class="hljs-comment">#     res = 0</span><br><span class="hljs-comment">#     tree = BIT(n + 1)</span><br><span class="hljs-comment">#     b = sorted(a)</span><br><span class="hljs-comment">#     for x in a:</span><br><span class="hljs-comment">#         i = bisect_right(b, x)</span><br><span class="hljs-comment">#         res += tree.query(n) - tree.query(i)</span><br><span class="hljs-comment">#         tree.update(i, 1)</span><br><span class="hljs-comment">#     return res</span><br><br><span class="hljs-comment"># 暴力求解逆序对，时间复杂度为n²</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inv</span>(<span class="hljs-params">a</span>):<br>    n = <span class="hljs-built_in">len</span>(a)<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> a[i] &gt; a[j]:<br>                res += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    odd, even = [], []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            odd.append(a[i])<br>        <span class="hljs-keyword">else</span>:<br>            even.append(a[i])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sorted</span>(odd) != <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)):<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> inv(odd) + inv(even)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) == <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]) == -<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">6</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]) == -<span class="hljs-number">1</span>)<br><br><br></code></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：O(n²)，主要由逆序数的双重循环计算决定。(可以用树状数组求解逆序对，时间复杂度为 O(nlogn))</li><li><strong>空间复杂度</strong>：O(n)，用于存储奇数和偶数下标的元素。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>逆序对</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>214小R的权值计算</title>
    <link href="/2024/12/25/214%E5%B0%8FR%E7%9A%84%E6%9D%83%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/12/25/214%E5%B0%8FR%E7%9A%84%E6%9D%83%E5%80%BC%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="问题理解"><a href="#问题理解" class="headerlink" title="问题理解"></a>问题理解</h3><p>给定一个长度为 <code>n</code> 的数组 <code>a</code>，小 R 定义任意子数组的权值为 <code>1×b₁ + 2×b₂ + ... + m×bₘ</code>，其中 <code>m</code> 是子数组的长度，<code>b₁, b₂, ..., bₘ</code> 是子数组中的元素。要求计算所有子数组权值的和，结果需对 <code>10^9 + 7</code> 取模。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>b1 b2 b3 b4 b5<br>b1+2b2 b2+2b3 b3+2b4 b4+2b5<br>b1+2b2+3b3 b2+2b3+3b4 b3+2b4+3b5<br>b1+2b2+3b3+4b4 b2+2b3+3b4+4b5<br>b1+2b2+3b3+4b4+5b5<br>根据规律可以看出长度为 length 的子数组转移的时候，只需要加上 length*a[i] - (s[i-1] - s[i-length-1])即可</p></blockquote><ol><li><p><strong>前缀和计算</strong>：<br>使用前缀和 <code>s</code> 来快速计算任意子数组的元素和，<code>s[i]</code> 表示前 <code>i</code> 个元素的和。</p></li><li><p><strong>权值计算</strong>：<br>对于每个子数组长度 <code>length</code>，遍历所有可能的子数组，计算当前子数组的权值 <code>cur</code>。</p><ul><li>初始时，计算第一个长度为 <code>length</code> 的子数组的权值。</li><li>随着窗口的滑动，通过更新 <code>cur</code> 来计算下一个子数组的权值：<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">cur += length * a<span class="hljs-comment">[i]</span> - (s<span class="hljs-comment">[i - 1]</span> - s<span class="hljs-comment">[i - length - 1]</span>)<br></code></pre></td></tr></table></figure>这里，<code>length * a[i]</code> 是新加入元素对权值的贡献，<code>(s[i - 1] - s[i - length - 1])</code> 是窗口内之前元素权值的调整。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> accumulate<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = <span class="hljs-number">0</span><br>    a = [<span class="hljs-number">0</span>] + a<br>    s = <span class="hljs-built_in">list</span>(accumulate(a))<br>    <span class="hljs-comment"># 枚举子数组的长度</span><br>    <span class="hljs-keyword">for</span> length <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        cur = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length + <span class="hljs-number">1</span>):<br>            cur += a[i] * i<br>        res = (res + cur) % mod<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            cur += length * a[i] - (s[i - <span class="hljs-number">1</span>] - s[i - length - <span class="hljs-number">1</span>])<br>            res = (res + cur) % mod<br>    <span class="hljs-keyword">return</span> res % mod<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) == <span class="hljs-number">33</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]) == <span class="hljs-number">203</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>]) == <span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>枚举</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>211小R的并集大小期望计算</title>
    <link href="/2024/12/24/211%E5%B0%8FR%E7%9A%84%E5%B9%B6%E9%9B%86%E5%A4%A7%E5%B0%8F%E6%9C%9F%E6%9C%9B%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/12/24/211%E5%B0%8FR%E7%9A%84%E5%B9%B6%E9%9B%86%E5%A4%A7%E5%B0%8F%E6%9C%9F%E6%9C%9B%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>小 R 有<code>n</code>个集合，每个集合中的元素都是唯一的且互不相同。她希望通过随机选择两个集合，并计算它们的并集大小，来求出并集大小的期望值。结果需要保留两位小数。题目保证输入至少有两个集合。</p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>要计算随机选择两个集合的并集大小的期望值，关键在于确定每个元素在这两个集合的并集中出现的概率。具体步骤如下：</p><ol><li><p><strong>元素出现次数统计</strong>：</p><ul><li>首先统计每个元素在所有集合中出现的次数。即，元素<code>x</code>出现于<code>v</code>个不同的集合中。</li></ul></li><li><p><strong>计算每个元素在并集中出现的概率</strong>：</p><ul><li>对于一个元素<code>x</code>，它至少出现在所选的两个集合中的一个的概率，可以通过以下公式计算：<script type="math/tex; mode=display">P(x \text{ 出现在并集中}) = 1 - P(x \text{ 不出现在两个集合中})</script></li><li><p><code>x</code>不出现在两个集合中的概率为：</p><script type="math/tex; mode=display">P(x \text{ 不出现在两个集合中}) = \frac{\binom{n - v}{2}}{\binom{n}{2}}</script><p>其中，(\binom{n}{2}) 表示从<code>n</code>个集合中选取两个集合的组合数。</p></li><li><p>因此，<code>x</code>出现在并集中的概率为：</p><script type="math/tex; mode=display">P(x \text{ 出现在并集中}) = 1 - \frac{(n - v) \times (n - v - 1)}{n \times (n - 1)}</script></li></ul></li><li><p><strong>计算期望值</strong>：</p><ul><li>期望值为所有元素在并集中出现概率的总和，即：<script type="math/tex; mode=display">\text{期望值} = \sum_{x} P(x \text{ 出现在并集中})</script></li></ul></li><li><p><strong>结果格式化</strong>：</p><ul><li>最终的期望值需要保留两位小数。</li></ul></li></ol><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, st: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-comment"># 统计所有元素在所有集合中出现的次数</span><br>    cnt = Counter([i <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> st <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s])<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> cnt.items():<br>        <span class="hljs-comment"># 对于每个元素，计算其出现在并集中的概率，并累加到结果中</span><br>        res += n * (n - <span class="hljs-number">1</span>) - (n - v) * (n - v - <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 计算期望值并格式化为两位小数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(res / (n * (n - <span class="hljs-number">1</span>)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]]) == <span class="hljs-string">&#x27;4.00&#x27;</span>)      <span class="hljs-comment"># 输出: True</span><br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]]) == <span class="hljs-string">&#x27;4.67&#x27;</span>)  <span class="hljs-comment"># 输出: True</span><br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">70</span>]]) == <span class="hljs-string">&#x27;5.00&#x27;</span>)  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>209 小R的子数组权值</title>
    <link href="/2024/12/24/209%E5%B0%8FR%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%9D%83%E5%80%BC/"/>
    <url>/2024/12/24/209%E5%B0%8FR%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%9D%83%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小 R 有一个长度为 <code>n</code> 的数组 <code>a</code>，她定义每个子区间 <code>[l, r]</code> 的权值为 <code>a[l] | a[l+1] | ... | a[r]</code>，即该区间内所有元素的按位或运算结果。小 R 非常好奇，在这 <code>n × (n + 1) / 2</code> 个子区间中，究竟有多少种不同的权值。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于两个二进制数 <code>a</code> 和 <code>b</code>，如果满足 <code>a &amp; b = a</code>，从集合的角度来看，<code>a</code> 对应的集合是 <code>b</code> 对应集合的子集。</p><ol><li><p><strong>遍历数组</strong>：仍然从左到右遍历数组 <code>a</code>，对于当前元素 <code>x = a[i]</code>。</p></li><li><p><strong>反向遍历更新</strong>：从索引 <code>i-1</code> 开始，向前遍历 <code>a[j]</code>：</p><ul><li><p><strong>检查子集关系</strong>：</p><ul><li><p>如果 <code>a[j] &amp; x != a[j]</code>，说明 <code>a[j]</code> 可以通过与 <code>x</code> 进行按位与运算而变小（即集合元素减少）。此时，更新 <code>a[j] = a[j] &amp; x</code>，并将更新后的值加入结果集合 <code>res</code> 中。</p></li><li><p>如果 <code>a[j] &amp; x == a[j]</code>，则 <code>x</code> 是 <code>a[j]</code> 的超集。同时，由于之前的遍历已经保证了每个集合都是其左侧相邻集合的超集，<code>x</code> 也必然是所有左侧集合的超集。在这种情况下，进一步的遍历将不会导致任何集合的变化，因此可以直接退出内层循环，提高算法效率。</p></li></ul></li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">a</span>):<br>    res = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):<br>        res.add(x)<br>        j = i - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> a[j] | x != a[j]:<br>            a[j] |= x<br>            res.add(a[j])<br>            j -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(res)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]) == <span class="hljs-number">6</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>]) == <span class="hljs-number">8</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]) == <span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：<code>O(nlog(U))</code>，其中 <code>n</code> 是数组的长度。<code>U</code>是数组中的最大值</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，用于存储不同的权值。</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://leetcode.cn/problems/number-of-subarrays-with-and-value-of-k/">LeetCode - Number of Subarrays With AND Value of K</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>logTrick</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>203小Q和小X的游戏</title>
    <link href="/2024/12/23/203%E5%B0%8FQ%E5%92%8C%E5%B0%8FX%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
    <url>/2024/12/23/203%E5%B0%8FQ%E5%92%8C%E5%B0%8FX%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="203-小-Q-和小-X-的游戏"><a href="#203-小-Q-和小-X-的游戏" class="headerlink" title="203 小 Q 和小 X 的游戏"></a>203 小 Q 和小 X 的游戏</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小 Q 和小 X 是很好的朋友，她们正在玩一个游戏。她们拿到了一个数组，游戏开始时小 Q 随机选择一个元素作为起点。接着，两人轮流行动，小 Q 先行动。</p><p>每次行动时，当前玩家需要选择当前元素左边比它更小的元素，然后移动到该元素，接下来换另一方从这个元素继续移动。如果某一方无法进行合法的移动，则该方输掉游戏。</p><p>小 Q 想知道，在双方都采取最优策略的情况下，她最终获胜的概率是多少？请输出分数的最简形式，即分子和分母互素。如果小 Q 必胜，则输出 <code>1/1</code>。如果小 Q 必败，则输出 <code>0/1</code>。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为起点是随机的，那么一共有 $n$ 种可能的起点。对于每个起点，我们可以通过模拟游戏的过程来判断小 Q 是否能获胜。</p><p>因为双方都采取最优策略，如果当前位置左边没有比它更小的元素，那么当前玩家必败。否则先手的小 Q 可以直接移动到左边的最小元素获得胜利。因此，我们可以通过统计当前位置左边是否存在比它更小的元素来判断小 Q 是否能获胜。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下是基于上述思路的 Python 代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> gcd<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    mi = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> a[i] &gt; mi:<br>            cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            mi = a[i]<br>    <span class="hljs-comment"># 计算最大公约数，化简分数</span><br>    g = gcd(cnt, n)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;cnt//g&#125;</span>/<span class="hljs-subst">&#123;n//g&#125;</span>&#x27;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]) == <span class="hljs-string">&#x27;3/5&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">6</span>, [<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]) == <span class="hljs-string">&#x27;2/3&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>]) == <span class="hljs-string">&#x27;1/4&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>193小K的区间与值和</title>
    <link href="/2024/12/23/193%E5%B0%8FK%E7%9A%84%E5%8C%BA%E9%97%B4%E4%B8%8E%E5%80%BC%E5%92%8C/"/>
    <url>/2024/12/23/193%E5%B0%8FK%E7%9A%84%E5%8C%BA%E9%97%B4%E4%B8%8E%E5%80%BC%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="193-小-K-的区间与值和"><a href="#193-小-K-的区间与值和" class="headerlink" title="193 小 K 的区间与值和"></a>193 小 K 的区间与值和</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小 K 有一个长度为 <code>n</code> 的数组 <code>a</code>，她定义数组的权值为数组中任意两个数按位与（bitwise AND）的值之和。具体来说，对于数组中的每个连续子数组，我们可以计算所有可能的两个元素的按位与值之和，并将这些值相加。小 K 想知道该数组中所有可能的连续子数组的权值和是多少，最后结果对 $10^9 + 7$ 取模。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>为了高效地计算所有连续子数组的权值和，我们需要找到一种方法避免枚举所有可能的子数组和其中的元素对。这可以通过逐位考虑每一位的贡献来实现。</p><p>具体步骤如下：</p><ol><li><p><strong>逐位处理</strong>：对于每一位 <code>i</code>（从第 0 位到第 31 位），计算该位在所有连续子数组中的贡献总和。</p></li><li><p><strong>统计位为 1 的情况</strong>：在数组中，如果某个元素的第 <code>i</code> 位为 1，那么它可以与之前位为 1 的元素形成按位与为 <code>1 &lt;&lt; i</code> 的对。</p></li><li><p><strong>计算子数组数量</strong>：对于 <code>nums[j]</code> 的每一位，考虑每个 <code>pair(i, j)</code> 满足 <code>nums[i] &amp; nums[j] = 1</code>，包含 <code>nums[i:j]</code> 的连续子数组左端点选择范围为 <code>[0 - i]</code>，右端点 <code>[j, n - 1]</code>，一共 <code>(i + 1) * (n - j)</code> 个。对于当前位置 <code>j</code>，我们可以统计出满足条件的 <code>i</code> 的个数累加起来，那么对于当前位置 <code>j</code>，满足条件的子数组个数为 <code>cnt * (n - j)</code>。</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> a[j] &gt;&gt; i &amp; <span class="hljs-number">1</span>:      <span class="hljs-comment"># 当前位是1</span><br>                res += cnt * (n - j) * (<span class="hljs-number">1</span> &lt;&lt; i)<br>                res %= mod<br>                cnt += j + <span class="hljs-number">1</span>  <span class="hljs-comment"># 统计满足条件的i的个数</span><br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) == <span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]) == <span class="hljs-number">25</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>]) == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>]) == <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 算法常用库函数</title>
    <link href="/2024/12/23/Python%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <url>/2024/12/23/Python%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍一些常用的 py 库函数</p></blockquote><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="1-1-abs-x"><a href="#1-1-abs-x" class="headerlink" title="1.1 abs(x)"></a>1.1 <code>abs(x)</code></h3><p>返回一个数字的绝对值。参数可以是整数、浮点数、复数等。如果参数是一个复数，则返回它的模。</p><h3 id="1-2-all-iterable"><a href="#1-2-all-iterable" class="headerlink" title="1.2 all(iterable)"></a>1.2 <code>all(iterable)</code></h3><p>如果 iterable 的所有元素均为真值（或可迭代对象为空）则返回 True 。<br>示例代码:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nums</span> =<span class="hljs-meta"> [1, 2, 3, 4, 5]</span><br><span class="hljs-comment"># 检查是否所有元素都是偶数</span><br><span class="hljs-attribute">print</span>(<span class="hljs-literal">all</span>(x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> for x in nums))  # False<br></code></pre></td></tr></table></figure><h3 id="1-3-any-iterable"><a href="#1-3-any-iterable" class="headerlink" title="1.3 any(iterable)"></a>1.3 <code>any(iterable)</code></h3><p>如果 iterable 的任一元素为真值则返回 True。 如果可迭代对象为空，返回 False。<br>例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nums</span> =<span class="hljs-meta"> [1, 2, 3, 4, 5]</span><br><span class="hljs-comment"># 检查列表中是否包含偶数</span><br><span class="hljs-attribute">print</span>(any(x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> for x in nums))  # True<br></code></pre></td></tr></table></figure><h3 id="1-4-bin-x"><a href="#1-4-bin-x" class="headerlink" title="1.4 bin(x)"></a>1.4 <code>bin(x)</code></h3><p>将一个整数转换为带前缀 “0b” 的二进制数字符串。<br>例:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">print</span>(bin(<span class="hljs-number">5</span>)) # <span class="hljs-number">0b101</span><br><span class="hljs-built_in">print</span>(bin(-<span class="hljs-number">6</span>)) # -<span class="hljs-number">0b110</span><br></code></pre></td></tr></table></figure><h3 id="1-5-chr-i-和-ord-c"><a href="#1-5-chr-i-和-ord-c" class="headerlink" title="1.5 chr(i) 和 ord(c)"></a>1.5 <code>chr(i)</code> 和 <code>ord(c)</code></h3><p>这两个函数互为逆函数。<br><code>chr(i)</code>返回 Unicode 码位为整数<code>i</code> 的字符的字符串格式。<br><code>ord(c)</code>对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span>(<span class="hljs-keyword">chr</span>(<span class="hljs-number">97</span>))  <span class="hljs-comment"># &#x27;a&#x27;</span><br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)) <span class="hljs-comment"># 97</span><br></code></pre></td></tr></table></figure><h3 id="1-6-divmod-a-b"><a href="#1-6-divmod-a-b" class="headerlink" title="1.6 divmod(a, b)"></a>1.6 <code>divmod(a, b)</code></h3><p>接受两个数字作为参数并返回由当对其使用整数除法时的商和余数组成的数字对。 结果与 (a // b, a % b) 相同。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>, b = divmod(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>)  # a = <span class="hljs-number">3</span>, b = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="1-7-enumerate-iterable-start-0"><a href="#1-7-enumerate-iterable-start-0" class="headerlink" title="1.7 enumerate(iterable, start=0)"></a>1.7 <code>enumerate(iterable, start=0)</code></h3><p>传入一个可迭代对象返回一个元组，里面包含一个计数值（从 start 开始，默认为 0）和通过迭代 iterable 获得的值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nums</span> =<span class="hljs-meta"> [100, 200, 300, 400, 500]</span><br><span class="hljs-comment"># [(1, 100), (2, 200), (3, 300), (4, 400), (5, 500)]</span><br><span class="hljs-attribute">print</span>(list(enumerate(nums, <span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><h3 id="1-8-eval-expression"><a href="#1-8-eval-expression" class="headerlink" title="1.8 eval(expression)"></a>1.8 <code>eval(expression)</code></h3><p>用来执行一个字符串表达式，并返回表达式的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">s = <span class="hljs-string">&quot;1 + 2 * 3 + 8 // 4&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">eval</span>(s))  <span class="hljs-comment"># 9</span><br></code></pre></td></tr></table></figure><h3 id="1-9-int-x-base-10"><a href="#1-9-int-x-base-10" class="headerlink" title="1.9 int(x, base=10)"></a>1.9 <code>int(x, base=10)</code></h3><p>将一个字符串或数字转换为整数。如果第二个参数 base 给出，则 x 必须是一个字符串，表示进制数（如 2 表示二进制，8 表示八进制，10 表示十进制，16 表示十六进制）。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;5&#x27;</span>))  <span class="hljs-meta"># 5</span><br><span class="hljs-keyword">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;1010&#x27;</span>, <span class="hljs-number">2</span>))  <span class="hljs-meta"># 10</span><br></code></pre></td></tr></table></figure><h3 id="1-10-max-iterable-key-default-和-min-iterable-key-default"><a href="#1-10-max-iterable-key-default-和-min-iterable-key-default" class="headerlink" title="1.10 max(iterable, *[, key, default]) 和 min(iterable, *[, key, default])"></a>1.10 <code>max(iterable, *[, key, default])</code> 和 <code>min(iterable, *[, key, default])</code></h3><p>大家都知道这两个函数的作用，需要注意的是，如果传入的可迭代对象为空，会抛出 _ValueError_ 异常。可以通过 default 参数设置默认返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(nums))  <span class="hljs-comment"># 5</span><br>nums2 = []<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(nums2))  <span class="hljs-comment"># ValueError: max() arg is an empty sequence</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(nums2, default=<span class="hljs-number">0</span>))  <span class="hljs-comment"># 0</span><br></code></pre></td></tr></table></figure><h3 id="1-11-pow-base-exp-mod-None"><a href="#1-11-pow-base-exp-mod-None" class="headerlink" title="1.11 pow(base, exp, mod=None)"></a>1.11 <code>pow(base, exp, mod=None)</code></h3><p>返回<em>base</em>的 exp 次幂；如果 mod 存在，则返回结果对 mod 取模。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-number">10</span>**<span class="hljs-number">9</span> + <span class="hljs-number">7</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 8</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, mod))  <span class="hljs-comment"># 703687441</span><br></code></pre></td></tr></table></figure><blockquote><p>在 3.8 版本 pow 函数支持求逆元</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, mod))  <span class="hljs-comment"># 500000004</span><br><span class="hljs-comment"># 等价于</span><br>inv = <span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">pow</span>(x, mod - <span class="hljs-number">2</span>, mod)<br><span class="hljs-built_in">print</span>(inv(<span class="hljs-number">2</span>))  <span class="hljs-comment"># 500000004</span><br></code></pre></td></tr></table></figure><h3 id="1-12-round-number-ndigits"><a href="#1-12-round-number-ndigits" class="headerlink" title="1.12 round(number[, ndigits])"></a>1.12 <code>round(number[, ndigits])</code></h3><p>返回浮点数 number 的四舍五入值，如果给出 ndigits 参数，返回值将根据 ndigits 的值四舍五入到小数点后的位数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">3.1415926</span>))  <span class="hljs-comment"># 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">3.1415926</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 3.14</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：round 函数的行为可能会有一些意外，例如 round(2.675, 2) 的结果是 2.67 而不是 2.68。</p></blockquote><h3 id="1-13-sorted-iterable-key-None-reverse-False"><a href="#1-13-sorted-iterable-key-None-reverse-False" class="headerlink" title="1.13 sorted(iterable, *, key=None, reverse=False)"></a>1.13 <code>sorted(iterable, *, key=None, reverse=False)</code></h3><p>返回一个排序后的列表。key 参数用于指定一个函数，用于从每个列表元素中提取用于比较的键。reverse 参数用于指定排序顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(nums))  <span class="hljs-comment"># [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(nums, reverse=<span class="hljs-literal">True</span>))  <span class="hljs-comment"># [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1]</span><br></code></pre></td></tr></table></figure><h3 id="1-14-str-x"><a href="#1-14-str-x" class="headerlink" title="1.14 str(x)"></a>1.14 <code>str(x)</code></h3><p>返回一个字符串对象。如果 x 不是字符串，则返回表示 x 的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(<span class="hljs-number">123</span>))  <span class="hljs-comment"># &#x27;123&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="1-15-sum-iterable-start-0"><a href="#1-15-sum-iterable-start-0" class="headerlink" title="1.15 sum(iterable, start=0)"></a>1.15 <code>sum(iterable, start=0)</code></h3><p>返回一个迭代器的总和。如果提供 start 参数，则会将 start 添加到总和中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>(nums))  <span class="hljs-comment"># 15</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>(nums, <span class="hljs-number">10</span>))  <span class="hljs-comment"># 25</span><br></code></pre></td></tr></table></figure><h3 id="1-16-zip-iterables"><a href="#1-16-zip-iterables" class="headerlink" title="1.16 zip(*iterables)"></a>1.16 <code>zip(*iterables)</code></h3><p>在多个迭代器上并行迭代，从每个迭代器返回一个数据项组成元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>letters = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(nums, letters)))  <span class="hljs-comment"># [(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;)]</span><br></code></pre></td></tr></table></figure><p>一个很好用的技巧是 zip 可以把矩阵的行变成列，列变成行，类似矩阵转置操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">g = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]]<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(*g):<br>  <span class="hljs-built_in">print</span>(row)<br><span class="hljs-comment"># (1, 4, 7)</span><br><span class="hljs-comment"># (2, 5, 8)</span><br><span class="hljs-comment"># (3, 6, 9)</span><br></code></pre></td></tr></table></figure><h2 id="2-collections-容器数据类型"><a href="#2-collections-容器数据类型" class="headerlink" title="2. collections 容器数据类型"></a>2. collections 容器数据类型</h2><h3 id="2-1-deque"><a href="#2-1-deque" class="headerlink" title="2.1 deque"></a>2.1 deque</h3><p>类似列表的容器，经常当作双端队列使用. append 和 pop 在其两端的速度都很快。<br>其中四个常用函数：<br><code>append(x)</code>：在右侧添加一个元素 x。<br><code>appendleft(x)</code>：在左侧添加一个元素 x。<br><code>pop()</code>：移除并返回最右侧的元素.<br><code>popleft()</code>：移除并返回最左侧的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">q = deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>q.append(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(q)  <span class="hljs-comment"># deque([1, 2, 3, 4])</span><br>q.appendleft(<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(q)  <span class="hljs-comment"># deque([0, 1, 2, 3, 4])</span><br><span class="hljs-built_in">print</span>(q.pop())  <span class="hljs-comment"># 4</span><br><span class="hljs-built_in">print</span>(q)  <span class="hljs-comment"># deque([0, 1, 2, 3])</span><br><span class="hljs-built_in">print</span>(q.popleft()) <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(q)  <span class="hljs-comment"># deque([1, 2, 3])</span><br></code></pre></td></tr></table></figure><h3 id="2-2-defaultdict"><a href="#2-2-defaultdict" class="headerlink" title="2.2 defaultdict"></a>2.2 defaultdict</h3><p>字典的子类，通过调用用户指定的工厂函数，为键提供默认值。<br>可以当成带默认值的字典使用。可以通过传入 int、list、set 等函数作为参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">d = defaultdict(<span class="hljs-built_in">int</span>)<br>d[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(d[<span class="hljs-string">&#x27;a&#x27;</span>])  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(d[<span class="hljs-string">&#x27;b&#x27;</span>])  <span class="hljs-comment"># 0</span><br>d = defaultdict(<span class="hljs-built_in">list</span>)<br>d[<span class="hljs-string">&#x27;a&#x27;</span>].append(<span class="hljs-number">1</span>)<br>d[<span class="hljs-string">&#x27;a&#x27;</span>].append(<span class="hljs-number">2</span>)<br>d[<span class="hljs-string">&#x27;b&#x27;</span>].append(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(d)  <span class="hljs-comment"># defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;a&#x27;: [1, 2], &#x27;b&#x27;: [3]&#125;)</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> d.items():<br>  <span class="hljs-built_in">print</span>(key, value)<br><span class="hljs-comment"># a [1, 2]</span><br><span class="hljs-comment"># b [3]</span><br></code></pre></td></tr></table></figure><h3 id="2-3-Counter"><a href="#2-3-Counter" class="headerlink" title="2.3 Counter"></a>2.3 Counter</h3><p>一个计数器工具, 提供快速和方便的计数方法。可以用于计数任何可哈希对象。元素存储为字典的键而它们的计数存储为字典的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 它和defaultdict(int) 类似，但是它可以支持初始化时传入一个可迭代对象</span><br>cnt = Counter([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-comment"># 其他用法和 defaultdict(int) 类似</span><br><br><span class="hljs-comment"># 但是Counter有一个好用的方法是most_common(n)方法，返回一个列表，其中包含 n 个最常见的元素及其计数。</span><br>cnt = Counter([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(cnt.most_common(<span class="hljs-number">2</span>))  <span class="hljs-comment"># [(3, 5), (1, 4)]</span><br></code></pre></td></tr></table></figure><h2 id="3-heapq-堆队列算法"><a href="#3-heapq-堆队列算法" class="headerlink" title="3. heapq 堆队列算法"></a>3. heapq 堆队列算法</h2><h3 id="3-1-heapify-x"><a href="#3-1-heapify-x" class="headerlink" title="3.1 heapify(x)"></a>3.1 heapify(x)</h3><p>将 list x 转换成堆，原地，线性时间内。</p><h3 id="3-2-heappush-heap-item"><a href="#3-2-heappush-heap-item" class="headerlink" title="3.2 heappush(heap, item)"></a>3.2 heappush(heap, item)</h3><p>将 item 的值加入 heap 中，保持堆的不变性。</p><h3 id="3-3-heappop-heap"><a href="#3-3-heappop-heap" class="headerlink" title="3.3 heappop(heap)"></a>3.3 heappop(heap)</h3><p>弹出并返回 heap 的最小的元素，保持堆的不变性。</p><h3 id="3-4-heapreplace-heap-item"><a href="#3-4-heapreplace-heap-item" class="headerlink" title="3.4 heapreplace(heap, item)"></a>3.4 heapreplace(heap, item)</h3><p>弹出并返回 heap 中最小的一项，同时推入新的 item。 堆的大小不变。</p><h3 id="3-5-heappushpop-heap-item"><a href="#3-5-heappushpop-heap-item" class="headerlink" title="3.5 heappushpop(heap, item)"></a>3.5 heappushpop(heap, item)</h3><p>将 item 放入堆中，然后弹出并返回 heap 的最小元素。</p><h3 id="3-6-nlargest-n-iterable-key-None-和-nsmallest-n-iterable-key-None"><a href="#3-6-nlargest-n-iterable-key-None-和-nsmallest-n-iterable-key-None" class="headerlink" title="3.6 nlargest(n, iterable, key=None) 和 nsmallest(n, iterable, key=None)"></a>3.6 nlargest(n, iterable, key=None) 和 nsmallest(n, iterable, key=None)</h3><p>从 iterable 所定义的数据集中返回前 n 个最大/最小元素组成的列表。 如果提供了 key 则其应指定一个单参数的函数</p><blockquote><p>注意 [heapify] 初始化生成的堆是最小堆，如果需要最大堆，可以将元素取负值。<br>涉及到堆的弹出操作，需要先判断堆是否为空。否则会抛出异常。<br>堆的组合操作 [heappushpop] 和 [heapreplace] 比两次操作组合起来更快。<br>[nlargest] 和 [nsmallest] 函数适用于 n 比较小的情况，n 比较大时，推荐使用 sorted 函数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> heapq <span class="hljs-keyword">import</span> *<br>h = [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]<br>heapify(h)<br><span class="hljs-built_in">print</span>(h)<br><span class="hljs-built_in">print</span>(heappop(h)) <span class="hljs-comment"># 1</span><br>heappush(h, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(h) <span class="hljs-comment"># [2, 3, 7, 4, 5]</span><br><span class="hljs-comment"># 先push再pop</span><br><span class="hljs-built_in">print</span>(heappushpop(h, <span class="hljs-number">1</span>)) <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(h) <span class="hljs-comment"># [2, 3, 7, 4, 5]</span><br><span class="hljs-comment"># 先pop再push</span><br><span class="hljs-built_in">print</span>(heapreplace(h, <span class="hljs-number">1</span>)) <span class="hljs-comment"># 2</span><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(nlargest(<span class="hljs-number">3</span>, a)) <span class="hljs-comment"># [8, 7, 5]</span><br><span class="hljs-built_in">print</span>(nsmallest(<span class="hljs-number">3</span>, a)) <span class="hljs-comment"># [1, 2, 3]</span><br><br></code></pre></td></tr></table></figure><h2 id="4-bisect-二分查找算法"><a href="#4-bisect-二分查找算法" class="headerlink" title="4. bisect 二分查找算法"></a>4. bisect 二分查找算法</h2><h3 id="4-1-bisect-left-a-x-lo-0-hi-len-a"><a href="#4-1-bisect-left-a-x-lo-0-hi-len-a" class="headerlink" title="4.1 bisect_left(a, x, lo=0, hi=len(a))"></a>4.1 bisect_left(a, x, lo=0, hi=len(a))</h3><p>找到第一个大于等于 x 的元素的位置，保证 <code>a[:pos]</code>都小于 x。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 返回在 a 中可以插入 x 的位置，使得 a 插入 x 之后仍然有序。</span><br><span class="hljs-comment"># 如果 a 中存在 x，则返回 x 左侧的位置。</span><br><span class="hljs-keyword">from</span> bisect <span class="hljs-keyword">import</span> bisect_left<br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]<br><span class="hljs-built_in">print</span>(bisect_left(a, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(bisect_left(a, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 6</span><br></code></pre></td></tr></table></figure><h3 id="4-2-bisect-right-a-x-lo-0-hi-len-a"><a href="#4-2-bisect-right-a-x-lo-0-hi-len-a" class="headerlink" title="4.2 bisect_right(a, x, lo=0, hi=len(a))"></a>4.2 bisect_right(a, x, lo=0, hi=len(a))</h3><p>找到第一个大于 x 的元素的位置，保证 <code>a[:pos]</code>都小于等于 x。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 返回在 a 中可以插入 x 的位置，使得 a 插入 x 之后仍然有序。</span><br><span class="hljs-comment"># 如果 a 中存在 x，则返回 x 右侧的位置。</span><br><span class="hljs-keyword">from</span> bisect <span class="hljs-keyword">import</span> bisect_right<br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]<br><span class="hljs-built_in">print</span>(bisect_right(a, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 4</span><br><span class="hljs-built_in">print</span>(bisect_right(a, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 6</span><br></code></pre></td></tr></table></figure><h3 id="4-3-insort-left-a-x-lo-0-hi-len-a-和-insort-right-a-x-lo-0-hi-len-a"><a href="#4-3-insort-left-a-x-lo-0-hi-len-a-和-insort-right-a-x-lo-0-hi-len-a" class="headerlink" title="4.3 insort_left(a, x, lo=0, hi=len(a)) 和 insort_right(a, x, lo=0, hi=len(a))"></a>4.3 insort_left(a, x, lo=0, hi=len(a)) 和 insort_right(a, x, lo=0, hi=len(a))</h3><p>insort_left 将 x 插入到列表 a 中，并保持 a 有序。如果 a 中存在 x，则插入在 x 左侧。<br>insort_right 将 x 插入到列表 a 中，并保持 a 有序。如果 a 中存在 x，则插入在 x 右侧。</p><blockquote><p>注意：虽然 insort 相关函数可以二分查找并直接插入元素到指定位置。但是时间复杂度为 O(n)。个人感觉使用场景不多</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Python</tag>
      
      <tag>库函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>149小A的移动点</title>
    <link href="/2024/12/23/149%E5%B0%8FA%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%82%B9/"/>
    <url>/2024/12/23/149%E5%B0%8FA%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>小 M 有<code>n</code>个点，每个点的坐标为 ($x_i$, $y_i$)。她可以从一个点出发，沿着坐标轴方向移动，直到到达另一个点。具体来说，可以从 <code>(x1, y1)</code> 直接移动到 <code>(x2, y1)</code> 或者 <code>(x1, y2)</code>，但无法直接移动到 <code>(x2, y2)</code>。为了确保任意两个点之间都可以通过这种路径互相到达，小 M 需要增加最少数量的新点。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个问题可以转化为图论中的连通性问题。将每个点看作图中的一个节点，如果两个点在同一行或同一列，则它们之间有一条边相连。我们需要找到图中的连通分量数目，然后最少需要增加的点数就是连通分量数目减一。</p><p>具体步骤如下：</p><ol><li><strong>并查集（Union-Find）</strong>：使用并查集数据结构来管理点的连接关系，方便快速合并和查找不同连通分量。</li><li><strong>建立行和列的映射</strong>：<ul><li>使用两个字典，<code>row</code> 和 <code>col</code>，分别存储每一行和每一列上的点的索引。</li><li>遍历所有点，将具有相同<code>x</code>坐标的点加入同一行，具有相同<code>y</code>坐标的点加入同一列。</li></ul></li><li><strong>合并连通分量</strong>：<ul><li>对于每一行中的所有点，依次将它们合并到第一点所在的连通分量。</li><li>对于每一列中的所有点，依次将它们合并到第一点所在的连通分量。</li></ul></li><li><strong>计算连通分量</strong>：<ul><li>最终，通过并查集找到所有点的根节点，统计不同的根节点数量，即为连通分量的数目。</li></ul></li><li><strong>得出结果</strong>：<ul><li>最少需要增加的点数为连通分量数目减一。</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, points: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    p = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">if</span> x != p[x]:<br>            p[x] = find(p[x])<br>        <span class="hljs-keyword">return</span> p[x]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>        x, y = find(x), find(y)<br>        <span class="hljs-keyword">if</span> x != y:<br>            p[y] = x<br><br>    row = defaultdict(<span class="hljs-built_in">list</span>)<br>    col = defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> i, (x, y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(points):<br>        row[x].append(i)<br>        col[y].append(i)<br><br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> row.values():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(v)):<br>            union(v[<span class="hljs-number">0</span>], v[i])<br><br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> col.values():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(v)):<br>            union(v[<span class="hljs-number">0</span>], v[i])<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(find(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n))) - <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]]) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>]]) == <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, [[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>]]) == <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>27游戏英雄升级潜力评估 一行代码解决</title>
    <link href="/2024/12/22/27%E6%B8%B8%E6%88%8F%E8%8B%B1%E9%9B%84%E5%8D%87%E7%BA%A7%E6%BD%9C%E5%8A%9B%E8%AF%84%E4%BC%B0-%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/12/22/27%E6%B8%B8%E6%88%8F%E8%8B%B1%E9%9B%84%E5%8D%87%E7%BA%A7%E6%BD%9C%E5%8A%9B%E8%AF%84%E4%BC%B0-%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小 U 在一款挂机游戏中拥有 n 个英雄。游戏中有一种历练升级机制，每天可以选择两个英雄进行历练，如果两位英雄的等级相同，则他们的等级都不会改变。如果英雄等级不同，那么等级较高的英雄会增加 1 级，而等级较低的英雄则保持不变。</p><p>小 U 希望至少有一个英雄能够达到<code>2000000000000000</code>级，现需要确定有多少英雄有潜力通过历练达到这个目标等级。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>要使至少有一个英雄达到<code>2000000000000000</code>级，必须确保有英雄能够不断提升等级。观察历练规则：</p><ul><li><strong>相同等级的英雄</strong>无法提升。</li><li><strong>不同等级的英雄</strong>中，等级较高的英雄每次历练都会增加 1 级。</li></ul><p>因此，只有不是最低等级的英雄才有可能通过不断历练达到高等级。最低等级的英雄无法提升，因此它们不具备达成目标的潜力。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li><strong>找出最低等级</strong>：确定所有英雄中当前的最低等级。</li><li><strong>计算最低等级英雄的数量</strong>：这些英雄无法通过历练提升。</li><li><strong>潜力英雄数量</strong>：总英雄数减去最低等级英雄的数量。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, u: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> n - u.count(<span class="hljs-built_in">min</span>(u))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(n = <span class="hljs-number">5</span>, u = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) == <span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(solution(n = <span class="hljs-number">4</span>, u = [<span class="hljs-number">100000</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">100000</span>]) == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(solution(n = <span class="hljs-number">6</span>, u = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]) == <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19 字典序最小的 01 字符串 简单 O(n)做法</title>
    <link href="/2024/12/22/19-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84-01-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%AE%80%E5%8D%95-O-n-%E5%81%9A%E6%B3%95/"/>
    <url>/2024/12/22/19-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84-01-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%AE%80%E5%8D%95-O-n-%E5%81%9A%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="19-字典序最小的-01-字符串-简单-O-n-做法"><a href="#19-字典序最小的-01-字符串-简单-O-n-做法" class="headerlink" title="19 字典序最小的 01 字符串 简单 O(n)做法"></a>19 字典序最小的 01 字符串 简单 O(n)做法</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 U 拥有一个由<code>0</code>和<code>1</code>组成的字符串，她可以进行最多<code>k</code>次操作。每次操作可以交换相邻的两个字符。目标是通过这些操作，使得最终得到的字符串字典序最小。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>为了获得字典序最小的字符串，我们的目标是尽可能将<code>&#39;0&#39;</code>移向字符串的左侧而把<code>&#39;1&#39;</code>移到字符串的右侧，并且根据字典序的规则，我们应该尽量把<code>&#39;1&#39;</code>和最右边的<code>&#39;0&#39;</code>交换</p><p>具体步骤如下：</p><ol><li><strong>遍历字符串</strong>：从左到右遍历字符串中的每一个字符。</li><li><strong>遇到<code>&#39;0&#39;</code>时尝试和左边的最远的<code>&#39;1&#39;</code>交换</strong>：<ul><li>对于当前位置的<code>&#39;0&#39;</code>，尝试将其向左边移动尽可能多的位置，但移动的步数不能超过剩余的操作次数<code>ops</code>。</li><li>用指针<code>j</code>记录最左边的<code>&#39;1&#39;</code>的位置，并且<code>j</code>具有单调性，因为假设当前的<code>i - j &gt; ops</code>，这意味着本次不能交换，那么当<code>i</code>继续向右移动时,<code>i - j</code>的值只会越来越大，所以<code>j</code>也必须向右继续移动才有可能进行交换。这也意味这<code>j</code>只会从<code>0~n</code>遍历一次，复杂度为$O(n)$</li><li>更新字符串，同时减少相应的操作次数<code>k</code>。</li></ul></li></ol><p>这种方法确保了在每一步操作中，都将当前的<code>&#39;0&#39;</code>尽可能地向左移动，从而整体上达到了字典序最小的目标。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, ops: <span class="hljs-built_in">int</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    s = <span class="hljs-built_in">list</span>(s)<br>    j = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j, i):<br>                <span class="hljs-keyword">if</span> s[k] == <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> (i - k) &lt;= ops:<br>                    s[k] = <span class="hljs-string">&#x27;0&#x27;</span><br>                    s[i] = <span class="hljs-string">&#x27;1&#x27;</span><br>                    ops -= (i - k)<br>                    j = k + <span class="hljs-number">1</span>  <span class="hljs-comment"># 更新j的位置</span><br>                    <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(s)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;01010&quot;</span>) == <span class="hljs-string">&#x27;00101&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;1101001&quot;</span>) == <span class="hljs-string">&#x27;0110101&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;1001&quot;</span>) == <span class="hljs-string">&#x27;0101&#x27;</span>)<br></code></pre></td></tr></table></figure><p>复杂度分析<br>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$<br>用于存储可变的字符串列表。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>146字符串首尾相同子序列计数</title>
    <link href="/2024/12/19/146%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%9B%B8%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0/"/>
    <url>/2024/12/19/146%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%9B%B8%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>小 M 拿到了一个仅由小写字母组成的字符串，她想知道在这个字符串中，有多少个子序列的首尾字符相同。子序列的定义是：从原字符串中按原顺序取出若干字符（可以不连续）组成的新字符串。</p><p>例如，对于字符串 “arcaea”，其子序列包括 “aca”, “ara”, “aaa” 等，这些子序列的首尾字符都是相同的。</p><p>你需要计算满足这一条件的子序列数量，并输出对 998244353 取模的结果。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p><strong>统计字符出现位置</strong>：<br>使用 <code>defaultdict</code> 来存储每个字符在字符串中出现的所有位置。</p></li><li><p><strong>计算子序列数量</strong>：<br>对于每个字符，考虑其所有可能的首尾位置组合 <code>(i, j)</code>，其中 $i &lt; j$。对于每一对 <code>(i, j)</code>，位于 $i$ 和 $j$ 之间的字符可以选择或不选择，因此有 $2^{j - i - 1}$ 种可能的子序列。</p></li><li><p><strong>累加结果</strong>：<br>将所有符合条件的子序列数量累加，同时加上单个字符的情况（每个字符本身也是一个有效的子序列）。</p></li><li><p><strong>取模处理</strong>：<br>最终结果对 <code>998244353</code> 取模。</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    d = defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>        d[c].append(i)<br>    res = <span class="hljs-number">0</span><br>    mod = <span class="hljs-number">998244353</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> d:<br>        v = d[k]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(v)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(v)):<br>                res += <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, v[j] - v[i] - <span class="hljs-number">1</span>, mod)<br>    <span class="hljs-keyword">return</span> (res + <span class="hljs-built_in">len</span>(s)) % mod<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;arcaea&quot;</span>) == <span class="hljs-number">28</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;abcabc&quot;</span>) == <span class="hljs-number">18</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-string">&quot;aaaaa&quot;</span>) == <span class="hljs-number">31</span>)<br></code></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：<code>O(N^2)</code>，其中 <code>N</code> 是字符串的长度。主要消耗在于双重循环遍历每个字符的所有位置组合。</li><li><strong>空间复杂度</strong>：<code>O(N)</code>，用于存储每个字符出现的位置。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>模数应为 <code>998244353</code>，请确保代码中 <code>mod</code> 的值正确。</li><li>由于可能存在大量的子序列，务必在计算中进行取模操作以防止整数溢出。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
